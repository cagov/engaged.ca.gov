<script>
// Global reference for button access
let narrativeDisplay;

class CanvasOutlineDrawer {
    constructor() {
        this.canvas = document.getElementById('narrative-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.style.opacity = 0;
        this.scrollableDiv = document.getElementById('narrative-wrapper-1');
        this.currentRenderFunction = null;
        
        // Retina scaling control - set to 1 to disable, 2 to enable
        this.retinaScale = 2;
        
        // Get device pixel ratio for reference
        this.devicePixelRatio = window.devicePixelRatio || 1;
        
        this.setupCanvas();
        this.setupEventListeners();
        this.draw();
    }

    setupCanvas() {
        // Set canvas size based on retina scale setting
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width * this.retinaScale;
        this.canvas.height = rect.height * this.retinaScale;
        
        // Scale context to match the retina scaling
        this.ctx.scale(this.retinaScale, this.retinaScale);
        
    }

    setupEventListeners() {
        // Redraw on scroll and resize
        // window.addEventListener('scroll', () => this.draw());
        window.addEventListener('resize', () => {
            this.setupCanvas();
            this.draw();
        });
    }

    getDivBounds() {
        const rect = this.scrollableDiv.getBoundingClientRect();
        return {
            x: rect.left,
            y: rect.top,
            width: rect.width,
            height: rect.height,
            right: rect.right,
            bottom: rect.bottom,
            visible: rect.bottom > 0 && rect.top < window.innerHeight && 
                    rect.right > 0 && rect.left < window.innerWidth
        };
    }

    setRenderFunction(render_function) {
        this.currentRenderFunction = render_function;
    }

    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    fadeOut() {
        // Set up a fade out transition for the canvas
        this.canvas.style.transition = 'opacity 0.5s';
        this.canvas.style.opacity = 0;
    }

    fadeIn() {
        // Set up a fade in transition for the canvas
        this.canvas.style.transition = 'opacity 0.5s';
        this.canvas.style.opacity = 1;
    }

    draw() {
        if (this.currentRenderFunction) {
            this.currentRenderFunction(this.ctx);
        }
    }

    drawRedCircle() {
        const ctx = this.ctx;
        
        // Circle properties
        const centerX = 50;
        const centerY = window.innerHeight / 2;
        const radius = 40;
        
        // Draw filled red circle
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Optional: Add a subtle border
        ctx.strokeStyle = '#cc0000';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    drawOutline(bounds) {
        const ctx = this.ctx;
        
        // Draw main outline
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        
        ctx.beginPath();
        ctx.rect(bounds.x, bounds.y, bounds.width, bounds.height);
        ctx.stroke();
        
        // Draw corner markers
        const cornerSize = 15;
        ctx.strokeStyle = '#4ecdc4';
        ctx.lineWidth = 2;
        
        // Top-left corner
        ctx.beginPath();
        ctx.moveTo(bounds.x, bounds.y + cornerSize);
        ctx.lineTo(bounds.x, bounds.y);
        ctx.lineTo(bounds.x + cornerSize, bounds.y);
        ctx.stroke();
        
        // Top-right corner
        ctx.beginPath();
        ctx.moveTo(bounds.right - cornerSize, bounds.y);
        ctx.lineTo(bounds.right, bounds.y);
        ctx.lineTo(bounds.right, bounds.y + cornerSize);
        ctx.stroke();
        
        // Bottom-right corner
        ctx.beginPath();
        ctx.moveTo(bounds.right, bounds.bottom - cornerSize);
        ctx.lineTo(bounds.right, bounds.bottom);
        ctx.lineTo(bounds.right - cornerSize, bounds.bottom);
        ctx.stroke();
        
        // Bottom-left corner
        ctx.beginPath();
        ctx.moveTo(bounds.x + cornerSize, bounds.bottom);
        ctx.lineTo(bounds.x, bounds.bottom);
        ctx.lineTo(bounds.x, bounds.bottom - cornerSize);
        ctx.stroke();
       
    }
}


// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    narrativeDisplay = new CanvasOutlineDrawer();
    console.log("narrativeDisplay", narrativeDisplay);
});

// Preload the report_icons.png sprite and draw it into an offscreen canvas for later use
let report_icons_canvas;
let report_icons_ctx;
const cycle_frequency = 0.2;

let k_minZoom = 0.925;
let k_maxZoom = 1.1; // 1.075;

function load_icons() {
    report_icons_canvas = document.createElement('canvas');
    report_icons_canvas.width = 4000;
    report_icons_canvas.height = 200;
    report_icons_ctx = report_icons_canvas.getContext('2d');

    const report_icons_img = new Image();
    report_icons_img.src = '/public/images/report_icons.png';
    console.log("loading report_icons_img");
    report_icons_img.onload = function() {
        console.log("report_icons_img loaded");
        report_icons_ctx.clearRect(0, 0, report_icons_canvas.width, report_icons_canvas.height);
        report_icons_ctx.drawImage(report_icons_img, 0, 0, 4000, 200);
    };
}


function render_icon(ctx, icon_index) {
    // console.log("render_icon", icon_index, x, y, scale);
    ctx.save();
        ctx.scale(0.5, 0.5);
        // Draw an orange circle around the icon image
        ctx.beginPath();
        ctx.arc(0, 0, 83, 0, 2 * Math.PI);
        ctx.lineWidth = 1.73*2;
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#E6883B';
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.drawImage(report_icons_canvas, icon_index * 200, 0, 200, 200, -100, -100, 200, 200);
    ctx.restore();
}

class Particle {
    constructor(x, y, options = {}) {
        this.x = x;
        this.y = y;
        this.options = options;
    }
}

let particles_1 = [];
let particles_2 = [];
let particles_3 = [];

function shuffled_order(nbr_particles) {
    let order = [];
    for (let i = 0; i < nbr_particles; i++) {
        order.push(i);
    }
    // Fisher-Yates shuffle
    for (let i = order.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [order[i], order[j]] = [order[j], order[i]];
    }
    return order;
}

function init_narrative_backgrounds_step_1() {
    const canvas = narrativeDisplay.canvas;
    // console.log("init 1, canvas size", canvas.width, canvas.height);

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    // console.log("canvas size", canvas.width, canvas.height);
    let canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    let canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    particles_1 = [];
    let ellipse_radius_x = canvas_width * 0.4;
    let ellipse_radius_y = (canvas_height-180) * 0.4;
    let ellipse_center_x = canvas_width / 2;
    let ellipse_center_y = canvas_height / 2 + 90;
    let balloon_colors = ['#98B8C8', '#E6F0F5', '#EFB389'];
    let text_color = '#868686';
    // produce order array (integers from 0->nbr_particles) which is shuffled.
    let particle_init = [
        {
            'ang_idx': 0,
            'width': 359,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 1,
        },
        {
            'ang_idx': 1,
            'width': 300,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 1,
        },
        {
            'ang_idx': 2,
            'width': 376,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 1,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 2, // secondary
            'x_offset': -75,
            'y_offset': 42,
            'width': 282,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 3,
            'width': 282,
            'color': 1,
            'balloon_type': 1,
            'nbr_text_lines': 3,
            'tail_upper': 1,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 4,
            'width': 269,
            'x_offset': 45,
            'y_offset': 0,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 4, // secondary
            'x_offset': 45-75,
            'y_offset': 42,
            'width': 269,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 5,
            'width': 378,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 6,
            'width': 261,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 6, // secondary
            'x_offset': -75,
            'y_offset': -42,
            'width': 262,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 7,
            'x_offset': 0,
            'y_offset': -100,
            'width': 445,
            'color': 2,
            'balloon_type': 1,
            'nbr_text_lines': 3,
            'tail_upper': 0,
        },
    ];
    let nbr_particles = particle_init.length;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    let nbr_angles = 8;

    for (let i = 0; i < nbr_particles; i++) {
        let pio = particle_init[i]; // particle init options
        let x_offset = (pio.hasOwnProperty('x_offset')) ? pio.x_offset : 0;
        let y_offset = (pio.hasOwnProperty('y_offset')) ? pio.y_offset : 0;
        let width = pio.width;
        let bg_color = balloon_colors[pio.color];
        let balloon_type = pio.balloon_type;
        let nbr_text_lines = pio.nbr_text_lines;
        let angle = pio.ang_idx * 2 * Math.PI / nbr_angles + Math.PI/nbr_angles;
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let scale = 1;
        let balloon_size = width * 0.4;
        let has_text_lines = nbr_text_lines > 0;
        let tail_reverse = (pio.hasOwnProperty('tail_reverse')) ? pio.tail_reverse : 0;
        let tail_upper = (pio.hasOwnProperty('tail_upper')) ? pio.tail_upper : 0;
        let aspect_ratio = balloon_type == 0? 544/312 : 922/685;
        let balloon_width = balloon_size * scale;
        let balloon_height = balloon_size * scale / aspect_ratio;
        let options = {
            'scale': scale,
            'x_offset': x_offset,
            'y_offset': y_offset,
            'ellipse_yw': ellipse_radius_y,
            'ellipse_xw': ellipse_radius_x,
            'body_width': balloon_width,
            'body_height': balloon_height,
            'balloon_corner_radius': 4*scale,
            'bg_color': bg_color,
            'text_color': text_color,
            'has_text_lines': has_text_lines,
            'tail_reverse': tail_reverse,
            'tail_upper': tail_upper,
            'nbr_text_lines': nbr_text_lines,
        }
        particles_1.push(new Particle(x, y, options));
    }
    // animate_step_1(0, ctx);
}

function animate_step_1(t, ctx) {

    particles_1.forEach(particle => {
      particle.options.opacity = mapv(t,0,1,0,1); // Math.pow(mapv(Math.sin(ease_in_out(t*0)*Math.PI*2*cycle_frequency + Math.PI*2*particle.options.phase), -1, 1, 0.5, 1), 2);
      particle.options.scale = mapv(t,0,1,0.1,1);
    });

    canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    particles_1.forEach(particle => {
        let center_x = canvas_width/2;
        let center_y = canvas_height/2 + 90;
        let tx = particle.x + particle.options.x_offset;
        let ty = particle.y + particle.options.y_offset;
        let sx = center_x + (tx - center_x) * 1.5;
        let sy = center_y + (ty - center_y) * 1.5;
        let x = mapv(t,0,1,sx,tx);
        let y = mapv(t,0,1,sy,ty);
        let scale = particle.options.scale;
        let balloon_size = particle.options.balloon_size;
        let bg_color = particle.options.bg_color;
        let text_color = particle.options.text_color;
        let text_size = particle.options.text_size;
        let has_text_lines = particle.options.has_text_lines;
        let tail_reverse = particle.options.tail_reverse;
        let tail_upper = particle.options.tail_upper;
        // Draw balloon body (rounded rect)
        const bodyWidth = particle.options.body_width;
        const bodyHeight = particle.options.body_height;
        const radius = particle.options.balloon_corner_radius;

        // Balloon body center
        const bx = x;
        const by = y;

        ctx.save();
        ctx.translate(bx, by);
        ctx.scale(scale, scale);
        if (tail_reverse) {
            ctx.scale(-1, 1);
        }
        if (tail_upper) {
            ctx.scale(1, -1);
        }

        // Balloon body rect
        const rectX = 0 - bodyWidth / 2;
        const rectY = 0 - bodyHeight / 2;
        const rectW = bodyWidth;
        const rectH = bodyHeight;

        ctx.globalAlpha = particle.options.opacity;

        ctx.beginPath();
        ctx.moveTo(rectX + radius, rectY);
        ctx.lineTo(rectX + rectW - radius, rectY);
        ctx.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
        ctx.lineTo(rectX + rectW, rectY + rectH - radius);
        ctx.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
        ctx.lineTo(rectX + radius, rectY + rectH);
        ctx.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
        ctx.lineTo(rectX, rectY + radius);
        ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);


        ctx.closePath();
        ctx.fillStyle = bg_color;
        ctx.strokeStyle = bg_color;
        ctx.fill();

        // Tail base (on bottom edge of rect, offset horizontally)
        let tailBaseX1 = rectX + bodyWidth*0.147; // bx + particle.options.tail_offset;
        let tailBaseY1 = rectY + bodyHeight; // rectY + rectH;
        let tailBaseX2 = rectX + bodyWidth*0.378;
        let tailBaseY2 = rectY + bodyHeight;

        // Tail tip (downward, at randomized angle and length)
        let tailTipX1 = tailBaseX1;
        let tailTipY1 = tailBaseY1 + bodyHeight * 0.23;
        let tailTipX2 = tailBaseX1 + bodyHeight * 0.05;
        let tailTipY2 = tailBaseY2 + bodyHeight * 0.24;

        // Draw tail (triangle)
        ctx.beginPath();
        ctx.moveTo(tailBaseX1-bodyWidth*0.05, tailBaseY1);
        ctx.quadraticCurveTo(tailBaseX1, tailBaseY1,
                             tailBaseX1, tailBaseY1 + bodyHeight*0.05);
        // Draw to just above the tip for a smoother curve
        ctx.lineTo(tailTipX1, tailTipY1);
        // Use quadratic curve for rounded tip
        ctx.quadraticCurveTo(
            tailTipX1, tailTipY1 + (bodyHeight * 0.05), // control point below tip for more roundness
            tailTipX2, tailTipY2
        );
        ctx.lineTo(tailBaseX2, tailBaseY2);
        ctx.lineWidth = 4*scale;
        ctx.fill();


        // Draw centered text
        if (has_text_lines) {
            let nbr_text_lines = particle.options.nbr_text_lines;
            let line_vert_margin = bodyHeight * 62/685;
            let line_gap_y = (bodyHeight - line_vert_margin * 2) / (nbr_text_lines + 1);
            let top_line_y = rectY + line_vert_margin + line_gap_y;
            let left_line_x = rectX + bodyWidth * 0.137;
            let right_line_x = rectX + bodyWidth - bodyWidth * 0.137;

            ctx.save();
            ctx.strokeStyle = text_color;
            ctx.lineWidth = 4;
            // console.log(nbr_text_lines, line_vert_margin, line_gap_y, top_line_y);

            for (let i = 0; i < nbr_text_lines; i++) {
                let line_y = top_line_y + i * line_gap_y;
                ctx.beginPath();
                ctx.moveTo(left_line_x, line_y);
                ctx.lineTo(right_line_x, line_y);
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.restore();
        ctx.globalAlpha = 1;

    });


}

function init_narrative_backgrounds_step_2() {
    let scale = 1;
    let canvas = narrativeDisplay.canvas;
    let canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    let canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    // console.log("canvas size 2", canvas.width, canvas.height);
    phrases = ['Utilities', 'Community/Support', "Financial/support", "Emergency/preparedness", 
               "Fire/proofing", "Building/permits"];

    let dot_colors = ['#98B8C8', '#EFB389'];


    particles_2 = [];
    let nbr_particles = 21;
    let min_ellipse_radius_x = canvas_width * 0.4;
    let max_ellipse_radius_x = canvas_width * 0.45;
    let min_ellipse_radius_y = (canvas_height-180) * 0.4;
    let max_ellipse_radius_y = (canvas_height-180) * 0.45;
    let ellipse_center_x = canvas_width / 2;
    let ellipse_center_y = canvas_height / 2 + 90;
    let text_index = 0;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 18*scale;
        let max_circle_size = 60*scale;
        let circle_size = mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*2);
        let text = '';
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        if (i % 3 == 0) {
            circle_type = 2;
            text = phrases[text_index];
            text_index = (text_index + 1) % phrases.length;
        }

        let options = {
            'phase': order[i] / nbr_particles,
            'circle_size': circle_size,
            'circle_type': circle_type,
            'text': text,
            'bg_color': bg_color,
            'ox': x,
            'oy': y,
            'travel_angle': Math.PI*2*Math.random(),
        }
        particles_2.push(new Particle(x, y, options));
    }
    console.log("nbr particles 2", particles_2);
    // animate_step_2(0, ctx);
}

function animate_step_2(t, ctx) {
    // TODO: implement animation for step 2
    // console.log("animate_step_2", t, "nbr particles", particles_2.length);

    particles_2.forEach(particle => {
        particle.options.opacity = Math.pow(mapv(Math.sin(ease_in_out(t*0)*Math.PI*2*cycle_frequency + Math.PI*2*particle.options.phase), -1, 1, 0.5, 1), 2);
        particle.options.scale = mapv(t,0,1,k_minZoom,k_maxZoom)*particle.options.opacity;
        let dist = t*50;
        let angle = particle.options.travel_angle;
        particle.x = particle.options.ox + dist * Math.cos(angle);
        particle.y = particle.options.oy + dist * Math.sin(angle);

        let x = particle.x;
        let y = particle.y;


        let circle_size = particle.options.circle_size;

        ctx.save();
        ctx.globalAlpha = particle.options.opacity;

        ctx.translate(x, y);
        ctx.scale(particle.options.scale, particle.options.scale);

        ctx.beginPath();
        ctx.arc(0, 0, circle_size, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*particle.options.scale;
        switch (particle.options.circle_type) {
        case 0:
        case 1:
            ctx.fillStyle = particle.options.bg_color;
            ctx.fill();
            break;
        case 2: // TEXT
            lines = particle.options.text.split('/');
            ctx.font = "italic 600 32px Noto Sans Display";
            ctx.textAlign = "center";
            ctx.fillStyle = '#868686';
            ctx.textBaseline = "middle";
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], 0, i * 50 - 20);
            }
            break;
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    });

}

let first_topic_particle = 0;

function init_narrative_backgrounds_step_3() {
    let scale = 1;

    let canvas = narrativeDisplay.canvas;
    let canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    let canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    // console.log("canvas size 3", canvas.width, canvas.height);
    let dot_colors = ['#98B8C8', '#EFB389'];

    particles_3 = [];
    let nbr_particles = 31;
    let min_ellipse_radius_x = canvas_width * 0.35;
    let max_ellipse_radius_x = canvas_width * 0.4;
    let min_ellipse_radius_y = (canvas_height-180) * 0.35;
    let max_ellipse_radius_y = (canvas_height-180) * 0.4;
    let ellipse_center_x = canvas_width / 2;
    let ellipse_center_y = canvas_height / 2 + 90;
    let nbr_icons = 20;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    let nbr_topics = 19;
    first_topic_particle = nbr_particles;

    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 15*scale;
        let max_circle_size = 50*scale;
        let circle_size = max_circle_size; // mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*Math.random()*2);
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        let options = {
            'phase': order[i] / nbr_particles,
            'circle_size': circle_size,
            'circle_type': circle_type,
            'bg_color': bg_color,
        }
        particles_3.push(new Particle(x, y, options));
    }
    let icon_index = 0;
    for (let i = 0; i < nbr_topics; i++) {
        let angle = i * 2 * Math.PI / nbr_topics;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let circle_size = 30*scale;
        let circle_type = 2;
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        icon_index = icon_index % nbr_icons;
        icon_index += 1;
        let options = {
            'phase': Math.floor(Math.random()*3),
            'circle_size': circle_size,
            'circle_type': circle_type,
            'icon_index': icon_index,
            'bg_color': bg_color,
            'ox': x,
            'oy': y,
            'travel_angle': Math.PI*2*Math.random(),
        }
        particles_3.push(new Particle(x, y, options));
    }
    for (let i = 0; i < nbr_particles; i++) {
        let closest_topic = null;
        let min_distance = 1000000;
        for (let j = 0; j < nbr_topics; j++) {
            let distance = Math.sqrt((particles_3[i].x - particles_3[first_topic_particle + j].x)**2 + (particles_3[i].y - particles_3[first_topic_particle + j].y)**2);
            if (distance < min_distance) {
                min_distance = distance;
                closest_topic = j;
            }
        }
        particles_3[i].options.closest_topic = closest_topic;
        particles_3[i].tx = particles_3[first_topic_particle + closest_topic].x;
        particles_3[i].ty = particles_3[first_topic_particle + closest_topic].y;
    }


    // console.log("nbr particles 3", particles_3);
    // animate_step_3(0, ctx);
}

function animate_step_3(t, ctx) {
    // TODO: implement animation for step 3
   // TODO: implement animation for step 2
    // console.log("animate_step_3", t, "nbr particles", particles_3.length);
    let canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    let canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    let opacity_peak = 0.6;

    particles_3.forEach(particle => {
        let x = particle.x;
        let y = particle.y;
        let opacity = 1;

        if (particle.options.circle_type < 2) {
            let begin_t = particle.options.phase * 1/4;
            let end_t = begin_t + 1/2;
            let phase_t = clamp(mapv(t, begin_t, end_t, 0, 1), 0, 1);

            let center_x = canvas_width/2;
            let center_y = canvas_height/2 + 90;


            let tx = particles_3[first_topic_particle + particle.options.closest_topic].x;
            let ty = particles_3[first_topic_particle + particle.options.closest_topic].y;


            let sx = center_x + (particle.x - center_x) * 2;
            let sy = center_y + (particle.y - center_y) * 2;
            x = mapv(phase_t,0,1,sx,tx);
            y = mapv(phase_t,0,1,sy,ty);
            particle.options.scale = mapv(phase_t,0,1,0.1,1);
            if (phase_t > opacity_peak) {
                particle.options.opacity = mapv(phase_t,opacity_peak,1,1,0);
            } else {
                particle.options.opacity = mapv(phase_t,0,opacity_peak,0,1);
            }
        } else {
            particle.options.opacity = 1;
            let dist = t*50;
            let angle = particle.options.travel_angle;
            particle.x = particle.options.ox + dist * Math.cos(angle);
            particle.y = particle.options.oy + dist * Math.sin(angle);
            particle.options.scale = mapv(t,0,1,1,1.2);
        }

        let circle_size = particle.options.circle_size;


        ctx.save();
        ctx.globalAlpha = particle.options.opacity;

        ctx.translate(x, y);
        ctx.scale(particle.options.scale, particle.options.scale);

        ctx.beginPath();
        ctx.arc(0, 0, circle_size, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*2;
        switch (particle.options.circle_type) {
        case 0:
        case 1:
            ctx.fillStyle = particle.options.bg_color;
            ctx.fill();
            break;
        case 2:
            render_icon(ctx, particle.options.icon_index);
            break;
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    });
    // console.log("  done animating step 3");
}



function init_narrative_backgrounds() {
    load_icons();

    init_narrative_backgrounds_step_1();

    init_narrative_backgrounds_step_2();

    init_narrative_backgrounds_step_3();

    console.log("narrative backgrounds initialized");

}

let current_animation_time = 0;
let current_animation_step_index = 0;

function refresh_narrative_backgrounds(ctx) {
    animate_narrative(current_animation_time, current_animation_step_index);
}

function animate_narrative(t, step_index) {
    // console.log("animating narrative for step", step_index, t);
    if (narrativeDisplay == null || narrativeDisplay.canvas == null) {
        return;
    }
    canvas = narrativeDisplay.canvas;
    let canvas_width = narrativeDisplay.canvas.width / narrativeDisplay.retinaScale;
    let canvas_height = narrativeDisplay.canvas.height / narrativeDisplay.retinaScale;

    let ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas_width, canvas_height);

    current_animation_time = t;
    current_animation_step_index = step_index;

    narrativeDisplay.setRenderFunction(refresh_narrative_backgrounds);

    // ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch (step_index) {
    case 1:
        animate_step_1(t, ctx);
        break;
    case 2:
        animate_step_2(t, ctx);
        break;
    case 3:
        animate_step_3(t, ctx);
        break;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    init_narrative_backgrounds();
    ScrollTrigger.refresh();

});
</script>