<script>

// Preload the report_icons.png sprite and draw it into an offscreen canvas for later use
let report_icons_canvas;
let report_icons_ctx;
const cycle_frequency = 0.2;

let k_minZoom = 0.925;
let k_maxZoom = 1.1; // 1.075;

function load_icons() {
    report_icons_canvas = document.createElement('canvas');
    report_icons_canvas.width = 4000;
    report_icons_canvas.height = 200;
    report_icons_ctx = report_icons_canvas.getContext('2d');

    const report_icons_img = new Image();
    report_icons_img.src = '/public/images/report_icons.png';
    console.log("loading report_icons_img");
    report_icons_img.onload = function() {
        console.log("report_icons_img loaded");
        report_icons_ctx.clearRect(0, 0, report_icons_canvas.width, report_icons_canvas.height);
        report_icons_ctx.drawImage(report_icons_img, 0, 0, 4000, 200);
    };
}


function render_icon(ctx, icon_index) {
    // console.log("render_icon", icon_index, x, y, scale);
    ctx.save();
        ctx.scale(0.8, 0.8);
        // Draw an orange circle around the icon image
        ctx.beginPath();
        ctx.arc(0, 0, 83, 0, 2 * Math.PI);
        ctx.lineWidth = 1.73*2;
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#E6883B';
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.drawImage(report_icons_canvas, icon_index * 200, 0, 200, 200, -100, -100, 200, 200);
    ctx.restore();
}

class Particle {
    constructor(x, y, options = {}) {
        this.x = x;
        this.y = y;
        this.options = options;
    }
}

let particles_1 = [];
let particles_2 = [];
let particles_3 = [];

// ADD RESIZE HANDLING HERE

function resize_canvas(step_nbr) {
    const canvas = document.getElementById(`findings-narrative-step-${step_nbr}-canvas`);
    const wrapper = document.getElementById(`narrative-wrapper-${step_nbr}`);
    const scale = 2;
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }
}

window.addEventListener('resize', function() {
    // this is not helping yet...
    resize_canvas(1);
    resize_canvas(2);
    resize_canvas(3);
});

function shuffled_order(nbr_particles) {
    let order = [];
    for (let i = 0; i < nbr_particles; i++) {
        order.push(i);
    }
    // Fisher-Yates shuffle
    for (let i = order.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [order[i], order[j]] = [order[j], order[i]];
    }
    return order;
}

function init_narrative_backgrounds_step_1(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    // console.log("init 1, canvas size", canvas.width, canvas.height);

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-1');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*2);
        canvas.height = Math.round(rect.height*2);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // console.log("canvas size", canvas.width, canvas.height);

    particles_1 = [];
    let ellipse_radius_x = canvas.width * 0.45;
    let ellipse_radius_y = canvas.height * 0.3;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    let balloon_colors = ['#98B8C8', '#E6F0F5', '#EFB389'];
    let text_color = '#868686';
    // produce order array (integers from 0->nbr_particles) which is shuffled.
    let particle_init = [
        {
            'ang_idx': 0,
            'width': 359,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 1,
        },
        {
            'ang_idx': 1,
            'width': 300,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 1,
        },
        {
            'ang_idx': 2,
            'width': 376,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 1,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 2, // secondary
            'x_offset': -150,
            'y_offset': 95,
            'width': 282,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 3,
            'width': 282,
            'color': 1,
            'balloon_type': 1,
            'nbr_text_lines': 3,
            'tail_upper': 1,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 4,
            'width': 269,
            'x_offset': 70,
            'y_offset': 0,
            'color': 2,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 4, // secondary
            'x_offset': 70-150,
            'y_offset': 78,
            'width': 269,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 5,
            'width': 378,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 6,
            'width': 261,
            'color': 1,
            'balloon_type': 0,
            'nbr_text_lines': 2,
            'tail_upper': 0,
            'tail_reverse': 1,
        },
        {
            'ang_idx': 6, // secondary
            'x_offset': -150,
            'y_offset': -78,
            'width': 262,
            'color': 0,
            'balloon_type': 0,
            'nbr_text_lines': 0,
            'tail_upper': 0,
        },
        {
            'ang_idx': 7,
            'x_offset': 0,
            'y_offset': -200,
            'width': 445,
            'color': 2,
            'balloon_type': 1,
            'nbr_text_lines': 3,
            'tail_upper': 0,
        },
    ];
    let nbr_particles = particle_init.length;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    let nbr_angles = 8;

    for (let i = 0; i < nbr_particles; i++) {
        let pio = particle_init[i]; // particle init options
        let x_offset = (pio.hasOwnProperty('x_offset')) ? pio.x_offset : 0;
        let y_offset = (pio.hasOwnProperty('y_offset')) ? pio.y_offset : 0;
        let width = pio.width;
        let bg_color = balloon_colors[pio.color];
        let balloon_type = pio.balloon_type;
        let nbr_text_lines = pio.nbr_text_lines;
        let angle = pio.ang_idx * 2 * Math.PI / nbr_angles + Math.PI/nbr_angles;
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let scale = 2;
        let balloon_size = width * 0.4;
        let has_text_lines = nbr_text_lines > 0;
        let tail_reverse = (pio.hasOwnProperty('tail_reverse')) ? pio.tail_reverse : 0;
        let tail_upper = (pio.hasOwnProperty('tail_upper')) ? pio.tail_upper : 0;
        let aspect_ratio = balloon_type == 0? 544/312 : 922/685;
        let balloon_width = balloon_size * scale;
        let balloon_height = balloon_size * scale / aspect_ratio;
        let options = {
            'scale': scale,
            'x_offset': x_offset,
            'y_offset': y_offset,
            'ellipse_yw': ellipse_radius_y,
            'ellipse_xw': ellipse_radius_x,
            'body_width': balloon_width,
            'body_height': balloon_height,
            'balloon_corner_radius': 4*scale,
            'bg_color': bg_color,
            'text_color': text_color,
            'has_text_lines': has_text_lines,
            'tail_reverse': tail_reverse,
            'tail_upper': tail_upper,
            'nbr_text_lines': nbr_text_lines,
        }
        particles_1.push(new Particle(x, y, options));
    }
    animate_step_1(0, ctx);
}

function animate_step_1(t, ctx) {
    // console.log("draw 1, canvas size", ctx.canvas.width, ctx.canvas.height);

    particles_1.forEach(particle => {
      particle.options.opacity = mapv(t,0,1,0,1); // Math.pow(mapv(Math.sin(ease_in_out(t*0)*Math.PI*2*cycle_frequency + Math.PI*2*particle.options.phase), -1, 1, 0.5, 1), 2);
      particle.options.scale = mapv(t,0,1,0.1,1);
    });

    let alpha;
    if (t < 0.1) {
        alpha = mapv(t, 0, 0.1, 0, 1);
    } else {
        alpha = 1;
    }
    ctx.canvas.style.opacity = alpha;

    particles_1.forEach(particle => {
        let tx = particle.x + particle.options.x_offset;
        let ty = particle.y + particle.options.y_offset;
        let sx = ctx.canvas.width/2 + (tx - ctx.canvas.width/2) * 1.5;
        let sy = ctx.canvas.height/2 + (ty - ctx.canvas.height/2) * 1.5;
        let x = mapv(t,0,1,sx,tx);
        let y = mapv(t,0,1,sy,ty);
        let scale = particle.options.scale;
        let balloon_size = particle.options.balloon_size;
        let bg_color = particle.options.bg_color;
        let text_color = particle.options.text_color;
        let text_size = particle.options.text_size;
        let has_text_lines = particle.options.has_text_lines;
        let tail_reverse = particle.options.tail_reverse;
        let tail_upper = particle.options.tail_upper;
        // Draw balloon body (rounded rect)
        const bodyWidth = particle.options.body_width;
        const bodyHeight = particle.options.body_height;
        const radius = particle.options.balloon_corner_radius;

        // Balloon body center
        const bx = x;
        const by = y;

        ctx.save();
        ctx.translate(bx, by);
        ctx.scale(scale, scale);
        if (tail_reverse) {
            ctx.scale(-1, 1);
        }
        if (tail_upper) {
            ctx.scale(1, -1);
        }

        // Balloon body rect
        const rectX = 0 - bodyWidth / 2;
        const rectY = 0 - bodyHeight / 2;
        const rectW = bodyWidth;
        const rectH = bodyHeight;

        ctx.globalAlpha = particle.options.opacity;

        ctx.beginPath();
        ctx.moveTo(rectX + radius, rectY);
        ctx.lineTo(rectX + rectW - radius, rectY);
        ctx.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
        ctx.lineTo(rectX + rectW, rectY + rectH - radius);
        ctx.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
        ctx.lineTo(rectX + radius, rectY + rectH);
        ctx.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
        ctx.lineTo(rectX, rectY + radius);
        ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);


        ctx.closePath();
        ctx.fillStyle = bg_color;
        ctx.strokeStyle = bg_color;
        ctx.fill();

        // Tail base (on bottom edge of rect, offset horizontally)
        let tailBaseX1 = rectX + bodyWidth*0.147; // bx + particle.options.tail_offset;
        let tailBaseY1 = rectY + bodyHeight; // rectY + rectH;
        let tailBaseX2 = rectX + bodyWidth*0.378;
        let tailBaseY2 = rectY + bodyHeight;

        // Tail tip (downward, at randomized angle and length)
        let tailTipX1 = tailBaseX1;
        let tailTipY1 = tailBaseY1 + bodyHeight * 0.23;
        let tailTipX2 = tailBaseX1 + bodyHeight * 0.05;
        let tailTipY2 = tailBaseY2 + bodyHeight * 0.24;

        // Draw tail (triangle)
        ctx.beginPath();
        ctx.moveTo(tailBaseX1-bodyWidth*0.05, tailBaseY1);
        ctx.quadraticCurveTo(tailBaseX1, tailBaseY1,
                             tailBaseX1, tailBaseY1 + bodyHeight*0.05);
        // Draw to just above the tip for a smoother curve
        ctx.lineTo(tailTipX1, tailTipY1);
        // Use quadratic curve for rounded tip
        ctx.quadraticCurveTo(
            tailTipX1, tailTipY1 + (bodyHeight * 0.05), // control point below tip for more roundness
            tailTipX2, tailTipY2
        );
        ctx.lineTo(tailBaseX2, tailBaseY2);
        ctx.lineWidth = 4*scale;
        ctx.fill();


        // Draw centered text
        if (has_text_lines) {
            let nbr_text_lines = particle.options.nbr_text_lines;
            let line_vert_margin = bodyHeight * 62/685;
            let line_gap_y = (bodyHeight - line_vert_margin * 2) / (nbr_text_lines + 1);
            let top_line_y = rectY + line_vert_margin + line_gap_y;
            let left_line_x = rectX + bodyWidth * 0.137;
            let right_line_x = rectX + bodyWidth - bodyWidth * 0.137;

            ctx.save();
            ctx.strokeStyle = text_color;
            ctx.lineWidth = 4;
            // console.log(nbr_text_lines, line_vert_margin, line_gap_y, top_line_y);

            for (let i = 0; i < nbr_text_lines; i++) {
                let line_y = top_line_y + i * line_gap_y;
                ctx.beginPath();
                ctx.moveTo(left_line_x, line_y);
                ctx.lineTo(right_line_x, line_y);
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.restore();
        ctx.globalAlpha = 1;

    });


}

function init_narrative_backgrounds_step_2(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    let aspect_ratio = canvas.height / canvas.width;
    let scale = 2;

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-2');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    {# ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height); #}

    // console.log("canvas size 2", canvas.width, canvas.height);
    phrases = ['Utilities', 'Community/Support', "Financial/support", "Emergency/preparedness", 
               "Fire/proofing", "Building/permits"];

    let dot_colors = ['#98B8C8', '#EFB389'];


    particles_2 = [];
    let nbr_particles = 21;
    let min_ellipse_radius_x = canvas.width * 0.4;
    let max_ellipse_radius_x = canvas.width * 0.45;
    let min_ellipse_radius_y = canvas.height * 0.2;
    let max_ellipse_radius_y = canvas.height * 0.45;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    let text_index = 0;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 18*scale;
        let max_circle_size = 60*scale;
        let circle_size = mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*2);
        let text = '';
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        if (i % 3 == 0) {
            circle_type = 2;
            text = phrases[text_index];
            text_index = (text_index + 1) % phrases.length;
        }

        let options = {
            'phase': order[i] / nbr_particles,
            'circle_size': circle_size,
            'circle_type': circle_type,
            'text': text,
            'bg_color': bg_color,
        }
        particles_2.push(new Particle(x, y, options));
    }
    console.log("nbr particles 2", particles_2);
    animate_step_2(0, ctx);
}

function animate_step_2(t, ctx) {
    // TODO: implement animation for step 2
    // console.log("animate_step_2", t, "nbr particles", particles_2.length);
    particles_2.forEach(particle => {
        particle.options.opacity = Math.pow(mapv(Math.sin(ease_in_out(t*0)*Math.PI*2*cycle_frequency + Math.PI*2*particle.options.phase), -1, 1, 0.5, 1), 2);
        particle.options.scale = mapv(t,0,1,k_minZoom,k_maxZoom)*particle.options.opacity;
    });

    let alpha;
    if (t < 0.1) {
        alpha = mapv(t, 0, 0.1, 0, 1);
    } else {
        alpha = 1;
    }
    alpha = 1;
    ctx.canvas.style.opacity = alpha;

    particles_2.forEach(particle => {
        let x = particle.x;
        let y = particle.y;


        let circle_size = particle.options.circle_size;

        ctx.save();
        ctx.globalAlpha = particle.options.opacity;

        ctx.translate(x, y);
        ctx.scale(particle.options.scale, particle.options.scale);

        ctx.beginPath();
        ctx.arc(0, 0, circle_size, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*particle.options.scale;
        switch (particle.options.circle_type) {
        case 0:
        case 1:
            ctx.fillStyle = particle.options.bg_color;
            ctx.fill();
            break;
        {# case 1:
            ctx.fillStyle = '#E5B389';
            ctx.fill();
            break;
        case 2: // TEXT #}
            lines = particle.options.text.split('/');
            ctx.font = "italic 600 32px Noto Sans Display";
            ctx.textAlign = "center";
            ctx.fillStyle = '#868686';
            ctx.textBaseline = "middle";
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], 0, i * 50 - 20);
            }
            break;
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    });

}

let first_topic_particle = 0;

function init_narrative_backgrounds_step_3(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    let aspect_ratio = canvas.height / canvas.width;
    let scale = 2;

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-3');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // console.log("canvas size 3", canvas.width, canvas.height);
    let dot_colors = ['#98B8C8', '#EFB389'];

    particles_3 = [];
    let nbr_particles = 31;
    let min_ellipse_radius_x = canvas.width * 0.37;
    let max_ellipse_radius_x = canvas.width * 0.45;
    let min_ellipse_radius_y = canvas.height * 0.2;
    let max_ellipse_radius_y = canvas.height * 0.3;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    let nbr_icons = 20;
    let order = shuffled_order(nbr_particles);
    let order2 = shuffled_order(nbr_particles);
    let nbr_topics = 19;
    first_topic_particle = nbr_particles;

    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 15*scale;
        let max_circle_size = 30*scale;
        let circle_size = max_circle_size; // mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*Math.random()*2);
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        let options = {
            'phase': order[i] / nbr_particles,
            'circle_size': circle_size,
            'circle_type': circle_type,
            'bg_color': bg_color,
        }
        particles_3.push(new Particle(x, y, options));
    }
    let icon_index = 0;
    for (let i = 0; i < nbr_topics; i++) {
        let angle = i * 2 * Math.PI / nbr_topics;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let circle_size = 30*scale;
        let circle_type = 2;
        let bg_color = dot_colors[Math.floor(Math.random()*dot_colors.length)];
        icon_index = icon_index % nbr_icons;
        icon_index += 1;
        let options = {
            'phase': Math.floor(Math.random()*3),
            'circle_size': circle_size,
            'circle_type': circle_type,
            'icon_index': icon_index,
            'bg_color': bg_color,
            'ox': x,
            'oy': y,
        }
        particles_3.push(new Particle(x, y, options));
    }
    for (let i = 0; i < nbr_particles; i++) {
        let closest_topic = null;
        let min_distance = 1000000;
        for (let j = 0; j < nbr_topics; j++) {
            let distance = Math.sqrt((particles_3[i].x - particles_3[first_topic_particle + j].x)**2 + (particles_3[i].y - particles_3[first_topic_particle + j].y)**2);
            if (distance < min_distance) {
                min_distance = distance;
                closest_topic = j;
            }
        }
        particles_3[i].options.closest_topic = closest_topic;
        particles_3[i].tx = particles_3[first_topic_particle + closest_topic].x;
        particles_3[i].ty = particles_3[first_topic_particle + closest_topic].y;
    }


    // console.log("nbr particles 3", particles_3);
    animate_step_3(0, ctx);
}

function animate_step_3(t, ctx) {
    // TODO: implement animation for step 3
   // TODO: implement animation for step 2
    // console.log("animate_step_3", t, "nbr particles", particles_3.length);

    let alpha;
    if (t < 0.1) {
        alpha = mapv(t, 0, 0.1, 0, 1);
    } else {
        alpha = 1;
    }
    alpha = 1;
    ctx.canvas.style.opacity = alpha;

    let opacity_peak = 0.6;

    particles_3.forEach(particle => {
        let x = particle.x;
        let y = particle.y;
        let opacity = 1;

        if (particle.options.circle_type < 2) {
            let begin_t = particle.options.phase * 1/4;
            let end_t = begin_t + 1/2;
            let phase_t = clamp(mapv(t, begin_t, end_t, 0, 1), 0, 1);


            let tx = particles_3[first_topic_particle + particle.options.closest_topic].x;
            let ty = particles_3[first_topic_particle + particle.options.closest_topic].y;


            let sx = ctx.canvas.width/2 + (particle.x - ctx.canvas.width/2) * 2;
            let sy = ctx.canvas.height/2 + (particle.y - ctx.canvas.height/2) * 2;
            x = mapv(phase_t,0,1,sx,tx);
            y = mapv(phase_t,0,1,sy,ty);
            particle.options.scale = mapv(phase_t,0,1,0.1,1);
            if (phase_t > opacity_peak) {
                particle.options.opacity = mapv(phase_t,opacity_peak,1,1,0);
            } else {
                particle.options.opacity = mapv(phase_t,0,opacity_peak,0,1);
            }
        } else {
            {# particle.options.scale = 1;
            particle.options.opacity = 1;
            let center_x = ctx.canvas.width/2;
            let center_y = ctx.canvas.height/2;
            let dx = particle.options.ox - center_x;
            let dy = particle.options.oy - center_y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let angle = Math.atan2(dy, dx);
            dist += ease_in_out(t)*20;
            angle += ease_in_out(t)*Math.PI/16;
            particle.x = center_x + dist * Math.cos(angle);
            particle.y = center_y + dist * Math.sin(angle); #}
            particle.options.scale = mapv(t,0,1,1,1.2);
        }



        let circle_size = particle.options.circle_size;


        ctx.save();
        ctx.globalAlpha = particle.options.opacity;

        ctx.translate(x, y);
        ctx.scale(particle.options.scale, particle.options.scale);

        ctx.beginPath();
        ctx.arc(0, 0, circle_size, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*2;
        switch (particle.options.circle_type) {
        case 0:
        case 1:
            ctx.fillStyle = particle.options.bg_color;
            ctx.fill();
            break;
        {# case 1:
            ctx.fillStyle = '#E5B389';
            ctx.fill();
            break; #}
        case 2:
            render_icon(ctx, particle.options.icon_index);
            break;
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    });
    // console.log("  done animating step 3");
}



function init_narrative_backgrounds() {
    load_icons();

    init_narrative_backgrounds_step_1('findings-narrative-step-1-canvas', 'red');

    init_narrative_backgrounds_step_2('findings-narrative-step-2-canvas', 'green');

    init_narrative_backgrounds_step_3('findings-narrative-step-3-canvas', 'blue');

    console.log("narrative backgrounds initialized");

}

function animate_narrative(t, step_index) {
    // console.log("animating narrative for step", step_index, t);
    const canvas_id = `findings-narrative-step-${step_index}-canvas`;
    const canvas = document.getElementById(canvas_id);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch (step_index) {
    case 1:
        animate_step_1(t, ctx);
        break;
    case 2:
        animate_step_2(t, ctx);
        break;
    case 3:
        animate_step_3(t, ctx);
        break;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    init_narrative_backgrounds();
    ScrollTrigger.refresh();

});
</script>