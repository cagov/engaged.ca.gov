<script>

class Particle {
    constructor(x, y, options = {}) {
        this.x = x;
        this.y = y;
        this.options = options;
    }
}

let particles_1 = [];
let particles_2 = [];
let particles_3 = [];

// ADD RESIZE HANDLING HERE

function resize_canvas(step_nbr) {
    const canvas = document.getElementById(`findings-narrative-step-${step_nbr}-canvas`);
    const wrapper = document.getElementById(`narrative-wrapper-${step_nbr}`);
    const scale = 2;
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }
}

window.addEventListener('resize', function() {
    // this is not helping yet...
    resize_canvas(1);
    resize_canvas(2);
    resize_canvas(3);
});


function init_narrative_backgrounds_step_1(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    console.log("init 1, canvas size", canvas.width, canvas.height);

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-1');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*2);
        canvas.height = Math.round(rect.height*2);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    console.log("canvas size", canvas.width, canvas.height);

    particles_1 = [];
    let nbr_particles = 10;
    let ellipse_radius_x = canvas.width * 0.4;
    let ellipse_radius_y = canvas.height * 0.4;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    let balloon_colors = ['#98B8C8', '#E6F0F5', '#EFB389'];
    let text_color = '#868686';
    // produce order array (integers from 0->nbr_particles) which is shuffled.
    let order = [];
    for (let i = 0; i < nbr_particles; i++) {
        order.push(i);
    }
    // Fisher-Yates shuffle
    for (let i = order.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [order[i], order[j]] = [order[j], order[i]];
    }
    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let scale = 2;
        let min_balloon_size = 40*scale;
        let max_balloon_size = 90*scale;
        let min_txt_size = 12*scale;
        let max_txt_size = 19*scale;
        let balloon_size = mapv(Math.random(),0,1,min_balloon_size,max_balloon_size);
        let size_split = (min_balloon_size + max_balloon_size) / 2;
        let bg_color = balloon_colors[Math.floor(Math.random()*balloon_colors.length)];
        let has_text_lines = Math.random() < 0.5;
        let tail_reverse = Math.random() < 0.5;
        let balloon_type = Math.random() < 0.4? 1 : 0;
        let aspect_ratio = balloon_type == 0? 544/312 : 922/685;
        let nbr_text_lines = balloon_type == 0? 2 : 3;
        let balloon_width = balloon_size * scale;
        let balloon_height = balloon_size * scale / aspect_ratio;
        let options = {
            'phase': order[i] / nbr_particles,
            'scale': scale,
            'ellipse_yw': ellipse_radius_y,
            'ellipse_xw': ellipse_radius_x,
            'ellipse_angle': angle,
            'body_width': balloon_width,
            'body_height': balloon_height,
            'balloon_corner_radius': 4*scale,
            'bg_color': bg_color,
            'text_color': text_color,
            'has_text_lines': has_text_lines,
            'tail_reverse': tail_reverse,
            'nbr_text_lines': nbr_text_lines,
            'opacity': 0,
        }
        particles_1.push(new Particle(x, y, options));
    }
    // animate_step(0, 1);
}

function animate_step_1(t, ctx) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    console.log("draw 1, canvas size", ctx.canvas.width, ctx.canvas.height);

    let alpha;
    if (t < 0.1) {
        alpha = mapv(t, 0, 0.1, 0, 1);
    } else {
        alpha = 1;
    }
    ctx.canvas.style.opacity = alpha;

    particles_1.forEach(particle => {
        let x = particle.x;
        let y = particle.y;
        let scale = particle.options.scale;
        let balloon_size = particle.options.balloon_size;
        let bg_color = particle.options.bg_color;
        let text_color = particle.options.text_color;
        let text_size = particle.options.text_size;
        let has_text_lines = particle.options.has_text_lines;
        let tail_reverse = particle.options.tail_reverse;
        // Draw balloon body (rounded rect)
        const bodyWidth = particle.options.body_width;
        const bodyHeight = particle.options.body_height;
        const radius = particle.options.balloon_corner_radius;

        // Balloon body center
        const bx = x;
        const by = y;

        ctx.save();
        ctx.translate(bx, by);
        if (tail_reverse) {
            ctx.scale(-1, 1);
        }

        // Balloon body rect
        const rectX = 0 - bodyWidth / 2;
        const rectY = 0 - bodyHeight / 2;
        const rectW = bodyWidth;
        const rectH = bodyHeight;

        ctx.globalAlpha = particle.options.opacity;
        ctx.save();

        ctx.beginPath();
        ctx.moveTo(rectX + radius, rectY);
        ctx.lineTo(rectX + rectW - radius, rectY);
        ctx.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
        ctx.lineTo(rectX + rectW, rectY + rectH - radius);
        ctx.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
        ctx.lineTo(rectX + radius, rectY + rectH);
        ctx.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
        ctx.lineTo(rectX, rectY + radius);
        ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);


        ctx.closePath();
        ctx.fillStyle = bg_color;
        ctx.strokeStyle = bg_color;
        ctx.fill();

        // Tail base (on bottom edge of rect, offset horizontally)
        let tailBaseX1 = rectX + bodyWidth*0.147; // bx + particle.options.tail_offset;
        let tailBaseY1 = rectY + bodyHeight; // rectY + rectH;
        let tailBaseX2 = rectX + bodyWidth*0.378;
        let tailBaseY2 = rectY + bodyHeight;

        // Tail tip (downward, at randomized angle and length)
        let tailTipX1 = tailBaseX1;
        let tailTipY1 = tailBaseY1 + bodyHeight * 0.23;
        let tailTipX2 = tailBaseX1 + bodyHeight * 0.05;
        let tailTipY2 = tailBaseY2 + bodyHeight * 0.24;

        // Draw tail (triangle)
        ctx.beginPath();
        ctx.moveTo(tailBaseX1-bodyWidth*0.05, tailBaseY1);
        ctx.quadraticCurveTo(tailBaseX1, tailBaseY1,
                             tailBaseX1, tailBaseY1 + bodyHeight*0.05);
        // Draw to just above the tip for a smoother curve
        ctx.lineTo(tailTipX1, tailTipY1);
        // Use quadratic curve for rounded tip
        ctx.quadraticCurveTo(
            tailTipX1, tailTipY1 + (bodyHeight * 0.05), // control point below tip for more roundness
            tailTipX2, tailTipY2
        );
        ctx.lineTo(tailBaseX2, tailBaseY2);
        ctx.lineWidth = 4*scale;
        ctx.fill();


        // Draw centered text
        if (has_text_lines) {
            let nbr_text_lines = particle.options.nbr_text_lines;
            let line_vert_margin = bodyHeight * 62/685;
            let line_gap_y = (bodyHeight - line_vert_margin * 2) / (nbr_text_lines + 1);
            let top_line_y = rectY + line_vert_margin + line_gap_y;
            let left_line_x = rectX + bodyWidth * 0.137;
            let right_line_x = rectX + bodyWidth - bodyWidth * 0.137;

            ctx.save();
            ctx.strokeStyle = text_color;
            ctx.lineWidth = 4;
            console.log(nbr_text_lines, line_vert_margin, line_gap_y, top_line_y);

            for (let i = 0; i < nbr_text_lines; i++) {
                let line_y = top_line_y + i * line_gap_y;
                ctx.beginPath();
                ctx.moveTo(left_line_x, line_y);
                ctx.lineTo(right_line_x, line_y);
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.restore();
        ctx.restore();
        ctx.globalAlpha = 1;

    });

    particles_1.forEach(particle => {
      particle.options.opacity = Math.pow(mapv(Math.sin(t*Math.PI*2 + Math.PI*2*particle.options.phase), -1, 1, 0, 1), 2);
    });

}

function init_narrative_backgrounds_step_2(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    let aspect_ratio = canvas.height / canvas.width;
    let scale = 2;

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-2');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    {# ctx.fillStyle = color;
    ctx.fillRect(0, 0, canvas.width, canvas.height); #}

    console.log("canvas size 2", canvas.width, canvas.height);

    particles_2 = [];
    let nbr_particles = 21;
    let min_ellipse_radius_x = canvas.width * 0.4;
    let max_ellipse_radius_x = canvas.width * 0.45;
    let min_ellipse_radius_y = canvas.height * 0.2;
    let max_ellipse_radius_y = canvas.height * 0.45;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 18*scale;
        let max_circle_size = 60*scale;
        let circle_size = mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*3);
        let options = {
            'scale': scale,
            'ellipse_yw': ellipse_radius_y,
            'ellipse_xw': ellipse_radius_x,
            'ellipse_angle': angle,
            'circle_size': circle_size,
            'circle_type': circle_type,
        }
        particles_2.push(new Particle(x, y, options));
    }
    console.log("nbr particles 2", particles_2);
    // animate_step(0, 2);
}

function init_narrative_backgrounds_step_3(canvas_id, color) {
    const canvas = document.getElementById(canvas_id);
    let aspect_ratio = canvas.height / canvas.width;
    let scale = 2;

    // Get the width and height in pixels of div#narrative-wrapper-1 and set canvas size to match
    const wrapper = document.getElementById('narrative-wrapper-3');
    if (wrapper) {
        const rect = wrapper.getBoundingClientRect();
        canvas.width = Math.round(rect.width*scale);
        canvas.height = Math.round(rect.height*scale);
    }

    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    console.log("canvas size 2", canvas.width, canvas.height);

    particles_3 = [];
    let nbr_particles = 31;
    let min_ellipse_radius_x = canvas.width * 0.4;
    let max_ellipse_radius_x = canvas.width * 0.45;
    let min_ellipse_radius_y = canvas.height * 0.2;
    let max_ellipse_radius_y = canvas.height * 0.45;
    let ellipse_center_x = canvas.width / 2;
    let ellipse_center_y = canvas.height / 2;
    for (let i = 0; i < nbr_particles; i++) {
        let angle = i * 2 * Math.PI / nbr_particles;
        let ellipse_radius_x = mapv(Math.random(),0,1,min_ellipse_radius_x,max_ellipse_radius_x);
        let ellipse_radius_y = mapv(Math.random(),0,1,min_ellipse_radius_y,max_ellipse_radius_y);
        let x = ellipse_center_x + ellipse_radius_x * Math.cos(angle);
        let y = ellipse_center_y + ellipse_radius_y * Math.sin(angle);
        let min_circle_size = 10*scale;
        let max_circle_size = 40*scale;
        let circle_size = mapv(Math.random(),0,1,min_circle_size,max_circle_size);
        let circle_type = Math.floor(Math.random()*Math.random()*3);
        let options = {
            'scale': scale,
            'ellipse_yw': ellipse_radius_y,
            'ellipse_xw': ellipse_radius_x,
            'ellipse_angle': angle,
            'circle_size': circle_size,
            'circle_type': circle_type,
        }
        particles_3.push(new Particle(x, y, options));
    }
    console.log("nbr particles 2", particles_3);
}





function animate_step_2(t, ctx) {
    // TODO: implement animation for step 2
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // console.log("animate_step_2", t, "nbr particles", particles_2.length);

    let alpha;
    if (t < 0.2) {
        alpha = mapv(t, 0, 0.2, 0, 0.8);
    {# } else if (t > 0.8) {
        alpha = mapv(t, 0.8, 1, 0.8, 0); #}
    } else {
        alpha = 0.8;
    }
    let size_scale = 1; // mapv(alpha, 0, 0.8, .2, 1)
    ctx.canvas.style.opacity = alpha;

    particles_2.forEach(particle => {
        let x = particle.x;
        let y = particle.y;
        let circle_size = particle.options.circle_size;


        ctx.save();

        ctx.beginPath();
        ctx.arc(x, y, circle_size*size_scale, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*particle.options.scale;
        switch (particle.options.circle_type) {
        case 0:
            ctx.fillStyle = '#5489A3';
            ctx.fill();
            break;
        case 1:
            ctx.fillStyle = '#E6883B';
            ctx.fill();
            break;
        case 2:
            ctx.strokeStyle = '#E6883B';
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.stroke();
            break;
        }
        ctx.restore();
    });


}

function animate_step_3(t, ctx) {
    // TODO: implement animation for step 3
   // TODO: implement animation for step 2

    // console.log("animate_step_2", t, "nbr particles", particles_2.length);

    let alpha;
    if (t < 0.2) {
        alpha = mapv(t, 0, 0.2, 0, 0.8);
    {# } else if (t > 0.8) {
        alpha = mapv(t, 0.8, 1, 0.8, 0); #}
    } else {
        alpha = 0.8;
    }
    ctx.canvas.style.opacity = alpha;

    particles_3.forEach(particle => {
        let x = particle.x;
        let y = particle.y;
        let circle_size = particle.options.circle_size;


        ctx.save();

        ctx.beginPath();
        ctx.arc(x, y, circle_size, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.lineWidth = 1.73*particle.options.scale;
        switch (particle.options.circle_type) {
        case 2:
            ctx.fillStyle = '#5489A3';
            ctx.fill();
            break;
        case 1:
            ctx.fillStyle = '#E6883B';
            ctx.fill();
            break;
        case 0:
            ctx.strokeStyle = '#E6883B';
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.stroke();
            break;
        }
        ctx.restore();
    });
}



function init_narrative_backgrounds() {
    init_narrative_backgrounds_step_1('findings-narrative-step-1-canvas', 'red');

    init_narrative_backgrounds_step_2('findings-narrative-step-2-canvas', 'green');

    init_narrative_backgrounds_step_3('findings-narrative-step-3-canvas', 'blue');

    console.log("narrative backgrounds initialized");

}

function animate_narrative(t, step_index) {
    // console.log("animating narrative for step", step_index, t);
    const canvas_id = `findings-narrative-step-${step_index}-canvas`;
    const canvas = document.getElementById(canvas_id);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    switch (step_index) {
    case 1:
        animate_step_1(t, ctx);
        break;
    case 2:
        animate_step_2(t, ctx);
        break;
    case 3:
        animate_step_3(t, ctx);
        break;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    init_narrative_backgrounds();
    ScrollTrigger.refresh();

});
</script>