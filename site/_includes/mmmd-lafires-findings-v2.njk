{% extends "layout.njk" %}
{% block content %}
<link rel="stylesheet" href="https://unpkg.com/lenis@1.3.8/dist/lenis.css">
<script src="https://unpkg.com/lenis@1.3.8/dist/lenis.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/ScrollTrigger.min.js"></script>

  <style>
    {# html, body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    } #}

   .canvas-wrapper {
      position: relative;
      width: 100%;
      height: 800px;
      background: #f0f0f0;
    }

    canvas {
      display: block;
      margin: 0 auto;
    }

    section {
      padding: 12px;
      font-size: 1.2rem;
      max-width: 1152px;
      margin: 0 auto;
    }
  </style>
</head>

<div class="canvas-wrapper">
  <canvas id="myCanvas" width="1152" height="800"></canvas>
</div>

<section>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi dignissim semper nisi, nec tempor elit bibendum eget.</p>
  <p>Sed tincidunt metus et felis blandit gravida. Curabitur fermentum diam sed ex cursus malesuada.</p>
  <p>Scroll down to reveal more text. This content scrolls normally after the pinned canvas section.</p>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed pretium tincidunt mauris, et dapibus orci.</p>
  <p>Nam vel commodo justo. Nullam sit amet tincidunt justo, ut suscipit ex.</p>
</section>

<div class="canvas-wrapper">
  <canvas id="secondCanvas" width="800" height="400"></canvas>
</div>

<!-- Include Libraries -->

<script>
  // Register GSAP plugin
  gsap.registerPlugin(ScrollTrigger);

  // Init Lenis
  const lenis = new Lenis({
    duration: 1.2,
    easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))
  });

  // Smooth scroll loop
  function raf(time) {
    lenis.raf(time);
    requestAnimationFrame(raf);
  }
  requestAnimationFrame(raf);

  // Let ScrollTrigger work with Lenis, necessary to avoid positioning glitches, especially when scrolling back up
  ScrollTrigger.scrollerProxy(document.body, {
    scrollTop(value) {
      return arguments.length ? lenis.scrollTo(value) : window.scrollY;
    },
    getBoundingClientRect() {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight
      };
    },
    pinType: document.body.style.transform ? "transform" : "fixed"
  });

  // Let ScrollTrigger use native scroll position while Lenis handles visual smoothing
  ScrollTrigger.refresh();

  // Canvas animation
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  let balloons = [];
  let balloonCount = 360;
  let speedFactor = 12;
  for (let i = 0; i < balloonCount; i++) {
    let size = Math.random()*Math.random() * 40 + 5; 
    let sx = Math.random() * width;
    let y_extra = size * speedFactor/2;
    let sy = Math.random() * (y_extra*2 + height) - y_extra;
    balloons.push({
      sx: sx,
      sy: sy,
      x: sx,
      y: sy,
      size: size,
      vy: size * speedFactor,
      // Alpha increases with size: min 0.3 for smallest, max 1 for largest
      // Vary luminance by Â±10 randomly
      color: `hsla(0, 0%, ${70 + (Math.random() * 5)}%, ${0.15 + 0.7 * ((size - 10) / 20)})`
    });
  }
  // Sort balloons by size ascending
  balloons.sort((a, b) => a.size - b.size);

  function drawBalloons(t) {
    updateBalloons(t);
    balloons.forEach(balloon => {
      // Draw a dialog balloon: rounded rect with a triangular tail

      // ctx.beginPath();
      // ctx.arc(balloon.x, balloon.y, balloon.size, 0, Math.PI * 2);
      // ctx.fillStyle = balloon.color;
      // ctx.fill();

      // Parameters for the balloon body
      const bodyWidth = balloon.size * 2.2;
      const bodyHeight = balloon.size * 1.4;
      const radius = Math.min(balloon.size * 0.6, 18);

      // Randomize tail orientation and length (per balloon, but fixed for each)
      if (balloon.tail === undefined) {
        // Angle: between -60deg and +60deg from vertical (in radians)
        balloon.tailAngle = (Math.random() - 0.5) * Math.PI / 1.5;
        // Length: between 0.7 and 1.2 times the size
        balloon.tailLength = balloon.size * (0.7 + Math.random() * 0.5);
        // Offset: horizontal offset from center, up to 0.5*bodyWidth
        balloon.tailOffset = (Math.random() - 0.5) * bodyWidth * 0.5;
        balloon.tail = true;
      }

      // Balloon body center
      const bx = balloon.x;
      const by = balloon.y;

      // Balloon body rect
      const rectX = bx - bodyWidth / 2;
      const rectY = by - bodyHeight / 2;
      const rectW = bodyWidth;
      const rectH = bodyHeight;

      // Tail base (on bottom edge of rect, offset horizontally)
      const tailBaseX = bx + balloon.tailOffset;
      const tailBaseY = rectY + rectH;

      // Tail tip (downward, at randomized angle and length)
      const tailTipX = tailBaseX + Math.sin(balloon.tailAngle) * balloon.tailLength;
      const tailTipY = tailBaseY + Math.cos(balloon.tailAngle) * balloon.tailLength;

      // Draw balloon body (rounded rect)
      ctx.beginPath();
      ctx.moveTo(rectX + radius, rectY);
      ctx.lineTo(rectX + rectW - radius, rectY);
      ctx.quadraticCurveTo(rectX + rectW, rectY, rectX + rectW, rectY + radius);
      ctx.lineTo(rectX + rectW, rectY + rectH - radius);
      ctx.quadraticCurveTo(rectX + rectW, rectY + rectH, rectX + rectW - radius, rectY + rectH);
      ctx.lineTo(rectX + radius, rectY + rectH);
      ctx.quadraticCurveTo(rectX, rectY + rectH, rectX, rectY + rectH - radius);
      ctx.lineTo(rectX, rectY + radius);
      ctx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);

      // Draw tail (triangle)
      ctx.moveTo(tailBaseX - radius * 0.5, tailBaseY);
      ctx.lineTo(tailTipX, tailTipY);
      ctx.lineTo(tailBaseX + radius * 0.5, tailBaseY);

      // Calculate bar dimensions
      const barWidth = rectW * (2/3);
      const barHeight = rectH * (1/19);
      const barSpacing = rectH * (1/9);

      // The left edge of the bars (centered horizontally)
      const barX = rectX + (rectW - barWidth) / 2;

      // Draw 3 bars as holes using even-odd fill rule
      // Start further down to avoid intersecting with top/bottom of balloon
      const totalBarsHeight = 3 * barHeight + 2 * barSpacing;
      const startY = rectY + rectH * 0.3; // Start at 25% down from top
      for (let i = 0; i < 3; i++) {
        const barY = startY + i * (barHeight + barSpacing);
        ctx.rect(barX, barY, barWidth, barHeight);
      }

      ctx.closePath();

      // Use even-odd fill rule to create holes
      ctx.fillStyle = balloon.color;
      ctx.fill('evenodd');
    });
  }

  function updateBalloons(t) {
    balloons.forEach(balloon => {
      balloon.y = balloon.sy + balloon.vy*t;
    });
  }

  function drawCircle(x) {
    ctx.beginPath();
    ctx.arc(x, height / 2, 20, 0, Math.PI * 2);
    ctx.fillStyle = 'red';
    ctx.fill();
  }

  // GSAP animation timeline synced to scroll
  gsap.to({}, {
    scrollTrigger: {
      trigger: ".canvas-wrapper",
      start: "top top",
      end: "+=2000", // scroll range for animation
      scrub: true,
      pin: true,
      onUpdate: (self) => {
        const t = self.progress; // 0 to 1
        const x = 20 + t * (width - 40);
        ctx.clearRect(0, 0, width, height);
        drawCircle(x);
        drawBalloons(t);
      }
    }
  });

  // Initial circle position
  drawCircle(20);
  drawBalloons(0);
</script>


{% endblock %}