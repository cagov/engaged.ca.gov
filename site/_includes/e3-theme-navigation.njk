<script>

let current_theme_index = 1;
let global_comment_data = null;
let current_search_term = '';
let current_sort = 'date'; // Default to date sort

// Function to escape HTML and highlight search terms
function highlightSearchText(text, searchTerm) {
  if (!searchTerm || searchTerm.length < 2) {
    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  
  // Escape HTML first
  let escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  
  // Create a regex to match the search term (case-insensitive)
  let regex = new RegExp('(' + searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi');
  
  // Replace matches with highlighted version
  return escapedText.replace(regex, '<mark>$1</mark>');
}

function populate_comments(theme_number_or_all) {
  if (global_comment_data == null) {
    console.log("Comment data not loaded yet");
    return;
  }
  
  let filtered_comments;
  
  // Handle "all" vs specific theme
  if (theme_number_or_all === 'all' || theme_number_or_all === null) {
    // Show all comments
    filtered_comments = global_comment_data.comments.filter(function(comment) {
      return comment.content && comment.content.trim() !== '';
    });
  } else {
    // Convert theme number (1-10) to mipid (0-9)
    let target_mipid = parseInt(theme_number_or_all, 10) - 1;
    
    // Filter comments by mipid
    filtered_comments = global_comment_data.comments.filter(function(comment) {
      return comment.mipid === target_mipid && comment.content && comment.content.trim() !== '';
    });
  }
  
  // Apply search filter if there's a search term
  if (current_search_term && current_search_term.length >= 2) {
    let search_lower = current_search_term.toLowerCase();
    filtered_comments = filtered_comments.filter(function(comment) {
      return comment.content.toLowerCase().includes(search_lower);
    });
  }
  
  // Function to parse date string to timestamp for comparison
  function parseDate(dateString) {
    if (!dateString) return 0;
    try {
      return new Date(dateString).getTime();
    } catch (e) {
      return 0;
    }
  }
  
  // Function to compare two comments based on current sort
  function compareComments(a, b) {
    if (current_sort === 'date') {
      // Date sort: sort by timestamp ascending
      let aDate = parseDate(a.date);
      let bDate = parseDate(b.date);
      if (aDate !== bDate) {
        return aDate - bDate;
      }
      // If dates are equal, use cid as tiebreaker
      return parseInt(a.cid, 10) - parseInt(b.cid, 10);
    } else if (current_sort === 'alpha') {
      // Alpha sort: use lowercase content
      let aText = (a.content || '').toLowerCase();
      let bText = (b.content || '').toLowerCase();
      if (aText < bText) return -1;
      if (aText > bText) return 1;
      return 0;
    } else if (current_sort === 'theme') {
      // Theme sort: sort by mipid first, then by date
      if (a.mipid !== b.mipid) {
        return a.mipid - b.mipid;
      }
      // Within same theme, sort by date
      let aDate = parseDate(a.date);
      let bDate = parseDate(b.date);
      if (aDate !== bDate) {
        return aDate - bDate;
      }
      return parseInt(a.cid, 10) - parseInt(b.cid, 10);
    } else if (current_sort === 'likes') {
      // Likes sort: descending order (most likes first)
      let aLikes = a.likes || 0;
      let bLikes = b.likes || 0;
      if (aLikes !== bLikes) {
        return bLikes - aLikes; // Descending
      }
      // If likes are equal, sort by date ascending
      let aDate = parseDate(a.date);
      let bDate = parseDate(b.date);
      if (aDate !== bDate) {
        return aDate - bDate;
      }
      return parseInt(a.cid, 10) - parseInt(b.cid, 10);
    } else if (current_sort === 'replies') {
      // Replies sort: descending order (most replies first)
      let aReplies = a.replies || 0;
      let bReplies = b.replies || 0;
      if (aReplies !== bReplies) {
        return bReplies - aReplies; // Descending
      }
      // If replies are equal, sort by date ascending
      let aDate = parseDate(a.date);
      let bDate = parseDate(b.date);
      if (aDate !== bDate) {
        return aDate - bDate;
      }
      return parseInt(a.cid, 10) - parseInt(b.cid, 10);
    }
    
    // Default fallback
    return 0;
  }
  
  // Build a map of comments by cid for easy lookup
  let comments_by_cid = {};
  filtered_comments.forEach(function(comment) {
    comments_by_cid[comment.cid] = comment;
  });
  
  // Separate top-level comments and replies
  let top_level = [];
  let replies = [];
  
  filtered_comments.forEach(function(comment) {
    if (comment.rid === '' || comment.rid === null || !comments_by_cid[comment.rid]) {
      top_level.push(comment);
    } else {
      replies.push(comment);
    }
  });
  
  // Sort top-level comments
  top_level.sort(compareComments);
  
  // Sort replies by date (chronological) - all replies will be sorted chronologically
  replies.sort(function(a, b) {
    let aDate = parseDate(a.date);
    let bDate = parseDate(b.date);
    if (aDate !== bDate) {
      return aDate - bDate;
    }
    return parseInt(a.cid, 10) - parseInt(b.cid, 10);
  });
  
  // Function to find all replies (direct and indirect) for a given comment
  function getAllReplies(parentCid, allReplies) {
    let result = [];
    allReplies.forEach(function(reply) {
      // Check if this reply is a direct or indirect child of parentCid
      let current = reply;
      let isDescendant = false;
      while (current.rid && current.rid !== '') {
        if (current.rid === parentCid) {
          isDescendant = true;
          break;
        }
        current = comments_by_cid[current.rid];
        if (!current) break;
      }
      if (isDescendant) {
        result.push(reply);
      }
    });
    return result;
  }
  
  // Build ordered list: for each top-level comment, add it followed by its replies
  let ordered_comments = [];
  top_level.forEach(function(parent) {
    ordered_comments.push(parent);
    // Get all replies (direct and indirect) for this parent
    let parentReplies = getAllReplies(parent.cid, replies);
    // Sort replies chronologically by date
    parentReplies.sort(function(a, b) {
      let aDate = parseDate(a.date);
      let bDate = parseDate(b.date);
      if (aDate !== bDate) {
        return aDate - bDate;
      }
      return parseInt(a.cid, 10) - parseInt(b.cid, 10);
    });
    // Add replies after parent
    ordered_comments = ordered_comments.concat(parentReplies);
  });
  
  // Update filtered_comments to the ordered list
  filtered_comments = ordered_comments;
  
  console.log(`Found ${filtered_comments.length} comments for ${theme_number_or_all === 'all' ? 'all themes' : 'theme ' + theme_number_or_all}`);
  
  // Build comment markup with highlighting
  let cmarkup = '';
  
  // Rebuild comments_by_cid map from ordered filtered_comments (in case we need it)
  // Note: comments_by_cid was already created earlier, but we'll update it with the ordered list
  filtered_comments.forEach(function(comment) {
    comments_by_cid[comment.cid] = comment;
  });
  
  // Function to check if a comment is a reply (has a parent)
  function isReply(comment) {
    return comment.rid !== '' && comment.rid !== null && comments_by_cid[comment.rid];
  }
  
  // Function to format date from ISO 8601 to "Month Day at HH:MMam/pm" format
  function formatDate(dateString) {
    if (!dateString) return '';
    try {
      let date = new Date(dateString);
      let months = ['January', 'February', 'March', 'April', 'May', 'June', 
                    'July', 'August', 'September', 'October', 'November', 'December'];
      let month = months[date.getMonth()];
      let day = date.getDate();
      let hours = date.getHours();
      let minutes = date.getMinutes();
      let ampm = hours >= 12 ? 'pm' : 'am';
      hours = hours % 12;
      hours = hours ? hours : 12; // 0 should be 12
      minutes = minutes < 10 ? '0' + minutes : minutes;
      return month + ' ' + day + ' at ' + hours + ':' + minutes + ampm;
    } catch (e) {
      return dateString; // Return original if parsing fails
    }
  }
  
  filtered_comments.forEach(function(comment) {
    // Use single indent for all replies (no nested indentation)
    let indent_class = isReply(comment) ? ' indent-reply' : '';
    
    let comment_text = comment.content.replace(/\n/g, ' ');
    let highlighted_text = highlightSearchText(comment_text, current_search_term);
    let formatted_date = formatDate(comment.date);
    let likes = comment.likes !== undefined ? comment.likes : 0;
    let has_likes = 'likes' in comment;
    
    cmarkup += `<div class="comment-item${indent_class}">`;
    cmarkup += '<div class="comment-content">';
    cmarkup += '"' + highlighted_text + '"';
    cmarkup += '</div>';
    if (formatted_date || has_likes) {
      cmarkup += '<div class="comment-meta">';
      if (formatted_date) {
        cmarkup += '<span class="comment-date">' + formatted_date + '</span>';
      }
      if (has_likes) {
        cmarkup += '<span class="comment-likes">';
        cmarkup += '<img src="/public/images/like-icon.svg" alt="likes" class="like-icon" />';
        cmarkup += ' ' + likes;
        cmarkup += '</span>';
      }
      cmarkup += '</div>';
    }
    cmarkup += '</div>';
  });
  
  // Update the comments container
  let comment_container = document.querySelector('.comments-container');
  if (comment_container) {
    if (filtered_comments.length === 0) {
      comment_container.innerHTML = '<p class="no-comments">No comments found.</p>';
    } else {
      comment_container.innerHTML = cmarkup;
    }
  }
  
  // Update theme selector dropdown
  let theme_selector = document.querySelector('.theme-selector');
  if (theme_selector) {
    if (theme_number_or_all === 'all') {
      theme_selector.value = 'all';
    } else {
      theme_selector.value = theme_number_or_all.toString();
    }
  }
}

function switch_theme(theme_number, should_scroll = false) {
  // Handle "all" option
  if (theme_number === 'all' || theme_number === null) {
    current_theme_index = 'all';
    populate_comments('all');
    return;
  }
  
  // Update current theme index
  current_theme_index = parseInt(theme_number, 10);
  
  // Remove 'active' class from all theme content sections
  document.querySelectorAll('.theme-content').forEach(function(content) {
    content.classList.remove('active');
  });
  
  // Add 'active' class to the selected theme content section
  let selected_content = document.getElementById(`theme-${theme_number}-content`);
  if (selected_content) {
    selected_content.classList.add('active');
    
    // Only scroll if explicitly requested (e.g., from hash navigation or direct link)
    if (should_scroll) {
      selected_content.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }
  
  // Update SVG circle highlighting - use stroke for selection instead of opacity
  document.querySelectorAll('.theme-circle').forEach(function(group) {
    let circle = group.querySelector('circle');
    let theme_num = parseInt(group.dataset.theme, 10);
    
    if (circle) {
      if (theme_num === theme_number) {
        // Highlight selected circle with white stroke
        circle.style.opacity = '1';
        circle.style.stroke = '#FFFFFF';
        circle.style.strokeWidth = '4';
        group.setAttribute('aria-selected', 'true');
      } else {
        // Reset to original state - restore original opacity, no stroke
        let fillColor = circle.getAttribute('fill');
        let originalOpacity = circle.getAttribute('opacity');
        if (originalOpacity) {
          circle.style.opacity = originalOpacity;
        } else {
          circle.style.opacity = '1';
        }
        circle.style.stroke = 'none';
        circle.style.strokeWidth = '0';
        group.setAttribute('aria-selected', 'false');
      }
    }
  });
  
  // Update navigation widget dots and buttons
  update_navigation_widget(theme_number);
  
  // Update comments for the new theme
  populate_comments(theme_number);
}

function update_navigation_widget(theme_number) {
  // Update dots
  document.querySelectorAll('.theme-dot').forEach(function(dot) {
    let dot_theme = parseInt(dot.dataset.theme, 10);
    if (dot_theme === theme_number) {
      dot.classList.add('active');
    } else {
      dot.classList.remove('active');
    }
  });
  
  // Get the total number of themes by counting dots
  let total_themes = document.querySelectorAll('.theme-dot').length;
  
  // Update Previous/Next buttons
  let prev_button = document.getElementById('theme-nav-prev');
  let next_button = document.getElementById('theme-nav-next');
  
  if (prev_button) {
    prev_button.disabled = (theme_number === 1);
  }
  if (next_button) {
    next_button.disabled = (theme_number === total_themes);
  }
}

document.addEventListener('DOMContentLoaded', function() {
  // Use event delegation on the SVG container for better Safari compatibility
  let svgContainer = document.querySelector('#themes-bubble-chart svg');
  if (svgContainer) {
    svgContainer.addEventListener('click', function(e) {
      let target = e.target;
      
      // Traverse up the DOM to find the theme-circle group
      let current = target;
      let themeGroup = null;
      
      // Check if target itself is a circle or group
      if (current.classList && current.classList.contains('theme-circle')) {
        themeGroup = current;
      } else if (current.tagName === 'circle' && current.parentElement) {
        themeGroup = current.parentElement;
      } else {
        // Traverse up to find parent group
        while (current && current !== svgContainer) {
          if (current.classList && current.classList.contains('theme-circle')) {
            themeGroup = current;
            break;
          }
          current = current.parentElement;
        }
      }
      
      if (themeGroup && themeGroup.dataset && themeGroup.dataset.theme) {
        let theme_number = parseInt(themeGroup.dataset.theme, 10);
        if (theme_number) {
          e.preventDefault();
          e.stopPropagation();
          // Clear any text selection to prevent blue rectangle
          if (window.getSelection) {
            window.getSelection().removeAllRanges();
          } else if (document.selection) {
            document.selection.empty();
          }
          switch_theme(theme_number, true); // Scroll when explicitly clicking
        }
      }
    });
  }
  
  // Set up event handlers for theme circles in SVG
  document.querySelectorAll('.theme-circle').forEach(function(circleGroup) {
    // Make the group focusable for accessibility
    circleGroup.setAttribute('tabindex', '0');
    circleGroup.setAttribute('role', 'button');
    let themeTitle = circleGroup.querySelector('text tspan')?.textContent || 'Theme ' + circleGroup.dataset.theme;
    circleGroup.setAttribute('aria-label', 'View ' + themeTitle);
    
    // Add keyboard support
    circleGroup.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        let theme_number = parseInt(this.dataset.theme, 10);
        switch_theme(theme_number, true); // Scroll when using keyboard navigation
      }
    });
    
    // Add hover effect - slightly darker on hover
    let circle = circleGroup.querySelector('circle');
    if (circle) {
      circleGroup.addEventListener('mouseenter', function() {
        let theme_num = parseInt(this.dataset.theme, 10);
        if (circle && current_theme_index !== theme_num) {
          circle.style.opacity = '0.9';
        }
      });
      circleGroup.addEventListener('mouseleave', function() {
        let theme_num = parseInt(this.dataset.theme, 10);
        if (circle && current_theme_index !== theme_num) {
          // Restore original opacity
          let originalOpacity = circle.getAttribute('opacity');
          if (originalOpacity) {
            circle.style.opacity = originalOpacity;
          } else {
            circle.style.opacity = '1';
          }
        }
      });
    }
  });
  
        // Handle hash navigation (e.g., #theme-3-content) - scroll when hash is present
        window.addEventListener('hashchange', function() {
          let hash = window.location.hash;
          let match = hash.match(/^#theme-(\d+)-content$/);
          if (match) {
            let theme_number = parseInt(match[1], 10);
            // Get the total number of themes by counting dots
            let total_themes = document.querySelectorAll('.theme-dot').length;
            if (theme_number >= 1 && theme_number <= total_themes) {
              switch_theme(theme_number, true); // Scroll when navigating via hash
            }
          }
        });
  
        // Check for initial hash on page load - scroll if hash is present
        if (window.location.hash) {
          let hash = window.location.hash;
          let match = hash.match(/^#theme-(\d+)-content$/);
          if (match) {
            let theme_number = parseInt(match[1], 10);
            // Get the total number of themes by counting dots
            let total_themes = document.querySelectorAll('.theme-dot').length;
            if (theme_number >= 1 && theme_number <= total_themes) {
              switch_theme(theme_number, true); // Scroll when page loads with hash
            }
          }
        }
  
  // Load comment data
  fetch("/public/data/E3_data_v1.json")
    .then(response => response.json())
    .then(data => {
      console.log("Comment data loaded:", data.comments.length, "comments");
      global_comment_data = data;
      // Populate comments for initial theme
      populate_comments(current_theme_index);
    })
    .catch(error => {
      console.error("Error fetching comment data:", error);
    });
  
  // Set up theme selector dropdown
  let theme_selector = document.querySelector('.theme-selector');
  if (theme_selector) {
    theme_selector.addEventListener('change', function() {
      let value = this.value;
      if (value === 'all') {
        switch_theme('all', false); // Don't scroll when changing dropdown
      } else {
        let theme_number = parseInt(value, 10);
        switch_theme(theme_number, false); // Don't scroll when changing dropdown
      }
    });
  }
  
  // Set up search input
  let search_input = document.querySelector('.search-input');
  if (search_input) {
    let search_timeout;
    search_input.addEventListener('input', function() {
      clearTimeout(search_timeout);
      let search_value = search_input.value.trim();
      
      // If search term is 2+ characters, automatically switch to "All"
      if (search_value.length >= 2) {
        if (current_theme_index !== 'all') {
          current_theme_index = 'all';
          if (theme_selector) {
            theme_selector.value = 'all';
          }
        }
        current_search_term = search_value;
        populate_comments('all');
      } else {
        // Clear search and use current theme
        current_search_term = '';
        if (current_theme_index === 'all') {
          // If we were on "all", switch back to theme 1
          current_theme_index = 1;
          if (theme_selector) {
            theme_selector.value = '1';
          }
          switch_theme(1, false);
        } else {
          populate_comments(current_theme_index);
        }
      }
    });
  }
  
  // Set up sort selector dropdown
  let sort_selector = document.querySelector('.sort-selector');
  if (sort_selector) {
    sort_selector.value = 'date'; // Set default to date
    sort_selector.addEventListener('change', function() {
      current_sort = this.value;
      // Repopulate comments with new sort
      if (current_theme_index === 'all') {
        populate_comments('all');
      } else {
        populate_comments(current_theme_index);
      }
    });
  }
  
  // Set up navigation widget buttons
  let prev_button = document.getElementById('theme-nav-prev');
  let next_button = document.getElementById('theme-nav-next');
  
  if (prev_button) {
    prev_button.addEventListener('click', function() {
      if (current_theme_index !== 'all' && current_theme_index > 1) {
        switch_theme(current_theme_index - 1, false); // Don't scroll when using nav widget
      }
    });
  }
  
  if (next_button) {
    next_button.addEventListener('click', function() {
      // Get the total number of themes by counting dots
      let total_themes = document.querySelectorAll('.theme-dot').length;
      if (current_theme_index !== 'all' && current_theme_index < total_themes) {
        switch_theme(current_theme_index + 1, false); // Don't scroll when using nav widget
      }
    });
  }
  
  // Set up navigation widget dots - make them clickable
  document.querySelectorAll('.theme-dot').forEach(function(dot) {
    dot.addEventListener('click', function() {
      let theme_number = parseInt(this.dataset.theme, 10);
      if (theme_number) {
        switch_theme(theme_number, false); // Don't scroll when clicking dots
      }
    });
  });
  
  // Initialize first theme as active (don't scroll on initial load unless there's a hash)
  if (!window.location.hash) {
    switch_theme(1, false); // Don't scroll on initial page load
  }
});

</script>
