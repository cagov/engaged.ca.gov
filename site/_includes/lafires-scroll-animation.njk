<script>
let topic_chart_setup = false;
const use_LENIS = true;
const use_MARKERS = false;

const pin_extend = 600; // was 600

document.addEventListener('DOMContentLoaded', function() {
  // IMPORTANT - if not in DOMContentLoaded, scroll aniimation is very unreliable due to potentially missing elements

  // Register GSAP plugin

  gsap.registerPlugin(ScrollTrigger);


  // Init Lenis
  if (use_LENIS) {
    const lenis = new Lenis({
      duration: 1.2,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))
    });

    // Smooth scroll loop
    function raf(time) {
      lenis.raf(time);
      requestAnimationFrame(raf);
    }
    requestAnimationFrame(raf); 

    // Let ScrollTrigger work with Lenis, necessary to avoid positioning glitches, especially when scrolling back up
    ScrollTrigger.scrollerProxy(document.body, {
      scrollTop(value) {
        return arguments.length ? lenis.scrollTo(value) : window.scrollY;
      },
      getBoundingClientRect() {
        return {
          top: 0,
          left: 0,
          width: window.innerWidth,
          height: window.innerHeight
        };
      },
      pinType: document.body.style.transform ? "transform" : "fixed"
    });
  }

  gsap.to({}, {
      scrollTrigger: {
        trigger: "#narrative-wrapper-1",
        start: "center center+=70",
        end: `+=${pin_extend}`, // scroll range for animation
        scrub: true,
        pin: true,
        anticipatePin: true,
        markers: use_MARKERS, // Enable markers for debugging
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          animate_narrative(t, 1);
        },
        onLeave: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeOut();
          }
        },
        onEnter: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeIn();
          }
        },
      }
  });
  
  gsap.to({}, {
      scrollTrigger: {
        trigger: "#narrative-wrapper-2",
        start: "center center+=70",
        end: `+=${pin_extend}`, // scroll range for animation
        scrub: true,
        pin: true,
        anticipatePin: true,
        markers: use_MARKERS, // Disable markers for pin trigger
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          animate_narrative(t, 2);
        },
        onLeave: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeOut();
          }
        },
        onEnter: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeIn();
          }
        },
      }
    });

  // Opacity trigger - handles the fade in/out animation
  gsap.to({}, {
      scrollTrigger: {
        trigger: "#narrative-wrapper-2",
        start: "middle bottom", // when middle hits bottom of viewport
        end: "bottom top+=140",   // when bottom edge hits top of viewport
        scrub: true,
        pin: false, // No pinning for this trigger
        markers: use_MARKERS, // Enable markers for debugging opacity
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          let opacity;
          if (t < 0.5) {
            opacity = clamp(mapv(t, 0, 0.3, 0, 1), 0, 1);
          } else {
            opacity = clamp(mapv(t, 0.7, 1, 1, 0), 0, 1);
          }
          let div = document.querySelector("#narrative-wrapper-2");
          if (div) {
            div.style.opacity = opacity;
            // div.style.transform = `scale(${0.5+opacity/2})`;
          }
          let divPre = document.querySelector("#narrative-wrapper-1");
          if (divPre) {
            divPre.style.opacity = 1 - opacity;
            // divPre.style.transform = `scale(${1 - opacity})`;
          }
        }
      }
    });

  gsap.to({}, {
      scrollTrigger: {
        trigger: "#narrative-wrapper-3",
        start: "center center+=70",
        end: `+=${pin_extend}`, // scroll range for animation
        scrub: true,
        pin: true,
        anticipatePin: true,
        markers: use_MARKERS, // Enable markers for debugging
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          animate_narrative(t, 3);
        },
        onLeave: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeOut();
          }
        },
        onEnter: (self) => {
          if (narrativeDrawer) {
            narrativeDrawer.fadeIn();
          }
        },
      }
    });

  gsap.to({}, {
      scrollTrigger: {
        trigger: "#narrative-wrapper-3",
        start: "middle bottom", // when middle hits bottom of viewport
        end: "bottom top",   // when bottom edge hits top of viewport
        scrub: true,
        pin: false, // No pinning for this trigger
        markers: use_MARKERS, // Enable markers for debugging opacity
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          let opacity;
          if (t < 0.5) {
            opacity = clamp(mapv(t, 0, 0.3, 0, 1), 0, 1);
          } else {
            opacity = clamp(mapv(t, 0.7, 1, 1, 0), 0, 1);
          }
          let div = document.querySelector("#narrative-wrapper-3");
          if (div) {
            div.style.opacity = opacity;
            // div.style.transform = `scale(${opacity})`;
          }
        },
      }
    });



  {# gsap.to({}, {
      scrollTrigger: {
        trigger: "#findings-top-options-1",
        start: "center center+=50",
        end: "+=900", // scroll range for animation
        scrub: true,
        pin: true,
        markers: use_MARKERS, // Enable markers for debugging
      }
    });

  gsap.to({}, {
      scrollTrigger: {
        trigger: "#findings-top-options-2",
        start: "center center+=50",
        end: "+=900", // scroll range for animation
        scrub: true,
        pin: true,
        markers: use_MARKERS, // Enable markers for debugging
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          if (consensus_vars.phase != 1) {
            consensus_chart_phase(1);
          }
        }
      }
    }); #}


  gsap.to({}, {
      scrollTrigger: {
       //  trigger: "#findings-consensus-sentiment-chart-dataviz-container",
        trigger: "#findings-consensus",

        start: "top bottom", // when bottom of object hits bottom of viewport
        end: "bottom top",         
        scrub: 1, // Add a small delay to smooth out the progress updates
        pin: false,
        markers: use_MARKERS, // Enable markers for debugging
        onUpdate: (self) => {
          const t = self.progress; // 0 to 1
          // At start (appears at bottom), set phase 1
          const canvas = document.getElementById('findings-consensus-sentiment-chart-dataviz-canvas');
          const canvas2 = document.getElementById('findings-consensus-progressbar-canvas');
          const div2 = document.getElementById('findings-consensus-progressbar-container');
          let opacity;
          if (t <= 0.4) {
            opacity = clamp(mapv(t, .2, 0.4, 0, 1), 0, 1);
          } else if (t > 0.6) {
            opacity = clamp(mapv(t, 0.6, 0.8, 1, 0), 0, 1);
          } else {
            opacity = 1;
          }
          if (canvas) {
            canvas.style.opacity = opacity;
          }
          if (canvas2) {
            canvas2.style.opacity = opacity;
            div2.style.width = `${clamp(opacity*1.3,0,1)*100}%`;
          }

          if (t <= 0.4 && consensus_vars.phase !== 1) {
            consensus_chart_phase(1);
          }
          // At center (about halfway), set phase 2
          else if (t > 0.4 && t < 0.6 && consensus_vars.phase !== 2) {
            consensus_chart_phase(2);
          }
          // At end (exits top), set phase 3
          else if (t >= 0.6 && consensus_vars.phase !== 3) {
            consensus_chart_phase(3);
          }
        }
      }
    });



  // Final refresh after all triggers are created
  ScrollTrigger.refresh();

});

</script>