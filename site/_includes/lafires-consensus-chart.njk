<script>

let consensus_vars = {
  "user_dots": [],
  "bandWidth": 0,
  "adj_band": 0,
  "ellipse_radius": 10,
  "vert_margin": 11,
  "voteData": null,
  "render_handle": null,
  "phase_handle": null,
  "phase": -1,
  "topic_number": 0,
  "canvas": null,
  "ctx": null
};


// UTILS
function mapv(v, in_min, in_max, out_min, out_max) {
  return (v-in_min) * (out_max-out_min) / (in_max-in_min) + out_min;
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}

function dot_distance(da, db) {
  let dx = da.tx - db.tx;
  let dy = da.ty - db.ty;
  return Math.sqrt(dx*dx + dy*dy);
}
function dot_angle(da, db) {
  let dx = db.tx - da.tx;
  let dy = db.ty - da.ty;
  return Math.atan2(dy, dx);
}

function compute_color(cx) {
  let r = cx/1200;
  let hue,sat,val;
  if (r < 0.5) {
    sat = Math.round(clamp(mapv(r, 0, 0.5, 76, 0),0,76)*100)/100;
    val = Math.round(clamp(mapv(r, 0, 0.5, 61, 85),61,85)*100)/100;
  } else {
    sat = Math.round(clamp(mapv(r, 0.5, 1, 0, 32),0,32)*100)/100;
    val = Math.round(clamp(mapv(r, 0.5, 1, 85, 48),48,85)*100)/100;
  }
  hue = Math.round(clamp(mapv(r,0.45, 0.55, 27, 200), 27, 200)*100)/100;
  return "hsl(" + hue + ", " + sat + "%, " + val + "%)";
}

// color debugging
for (let i = 0; i < 7; ++i) {
  let cx = mapv(i,0,6,0,1200);
  let color = compute_color(cx);
  // console.log("color",i+1, color);
}

function reset_user_dots(topic_index) {
    let userRecs = consensus_vars.voteData['user_recs'];
    let fUserRecords = userRecs.filter(rec => rec.tid == topic_index);

    let encountered_uids = {};

    fUserRecords.forEach(rec => {
      let uid = rec.uid;
      encountered_uids[uid] = true;
      let user_dot = consensus_vars.user_dots[uid];

      let likert = rec.v;
      // Clamp likert to [1,7]
      if (likert < 1) likert = 1;
      if (likert > 7) likert = 7;
      let dot_x = consensus_vars.bandWidth * (likert - 0.5);
      x_offset = user_dot.rx * consensus_vars.adj_band - consensus_vars.adj_band / 2;
      dot_x += x_offset;
      user_dot.min_x = topic_vars.bandWidth * (likert - 0.5) - topic_vars.adj_band / 2;
      user_dot.max_x = topic_vars.bandWidth * (likert - 0.5) + topic_vars.adj_band / 2;
      user_dot.tx = dot_x;
      user_dot.topacity = 1;
      user_dot.active = true;

      let dot_y = topic_vars.vert_margin + user_dot.ry * (ctx.canvas.height-topic_vars.vert_margin*2);
      user_dot.ty = dot_y;
      user_dot.vx = 0;
      user_dot.vy = 0;

      /* coord forcing, if used, goes here... */

      if (user_dot.copacity < 0.1) {
        user_dot.cx = user_dot.tx;
      }
    });

    // For each user that is not in the fUserRecords, set the opacity to 0
    for (let uid = 0; uid < consensus_vars.voteData.nbr_users; uid++) {
      if (!encountered_uids[uid]) {
        consensus_vars.user_dots[uid].topacity = 0;
        consensus_vars.user_dots[uid].tx = consensus_vars.user_dots[uid].cx;
      }
    }
}

function apply_consensus_forces(ctx) {
  let activeDots = consensus_vars.user_dots.filter(d => d.active);
  let canvas = ctx.canvas;
  let gravityForce = 0.025;
  let borderForce = 0.2;
  let maxRepelForce = 0.1;
  let repelScale = 1.2; // 1.1



  activeDots.forEach(dot => {
    dot.vx *= 0.95;
    dot.vy *= 0.95;
    let fx = 0;
    let fy = 0;
    // compute forces from neighbors
    let min_distance = topic_vars.ellipse_radius*2 * repelScale;
    let neighbors = activeDots.filter(d => d.uid != dot.uid && dot_distance(d, dot) < min_distance);
    neighbors.forEach(neb => {
      let dist = dot_distance(neb, dot);
      let angle = dot_angle(neb, dot);
      // To make force 0 at d = min_distance, and increase as d gets smaller:
      // We'll use: force = (min_distance - d) / min_distance, but clamp to >= 0
      let force = clamp((min_distance - dist) / min_distance, 0, maxRepelForce);
      fx += force * Math.cos(angle);
      fy += force * Math.sin(angle);
    });
    // contain within rectangle
    if (dot.tx >= canvas.width - topic_vars.ellipse_radius*2) {
      fx -= borderForce;
    } else if (dot.tx <= topic_vars.ellipse_radius*2) {
      fx += borderForce;
    }
    if (dot.tx >= dot.max_x) {
      fx -= borderForce;
    } else if (dot.tx <= dot.min_x) {
      fx += borderForce;
    }

    if (dot.ty >= canvas.height - topic_vars.ellipse_radius) {
      fy -= borderForce;
    } else if (dot.ty <= topic_vars.ellipse_radius) {
      fy += borderForce;
    }
    {# // compute weak forces from gravity to center line - UNUSED
    let center_y = ctx.canvas.height/2;
    let dy = dot.ty - center_y;
    if (dy > 2) {
      fy -= gravityForce;
    } else if (dy < -2) {
      fy += gravityForce;
    } #}
    dot.vx += fx;
    dot.vy += fy;
    dot.tx += dot.vx;
    dot.ty += dot.vy;
  });
}

function change_consensus_topic(canvas, topic_index) {
    // console.log("render_topic", topic_index);
    consensus_vars.topic_number = topic_index;
    let ctx = canvas.getContext('2d');
    consensus_vars.bandWidth = ctx.canvas.width / 7;
    consensus_vars.adj_band = consensus_vars.bandWidth - consensus_vars.ellipse_radius*2;

    if (consensus_vars.render_handle) {
      clearInterval(consensus_vars.render_handle);
    }


    reset_user_dots(topic_index);
    let topic_names = consensus_vars.voteData['topics'];
    let topic_number_template = '{{ modules.findings_consensus_watch_explore.topic_number_template | safe}}';
    let topic_number_string = topic_number_template.replace('<NUM>', topic_index + 1).replace('<TOTAL>', topic_names.length);

    let topic_perecent_template = '{{ modules.findings_consensus_watch_explore.percent_template | safe}}';
    let topic_percent_string = topic_perecent_template.replace('<PERCENT>', Math.round(topic_names[topic_index][3]*100))

    document.getElementById('findings-consensus-sentiment-chart-topic-number').innerHTML = topic_number_string;
    // let topic_number_label = f'Topic {topic_index + 1} of {topic_names.length}'; // TRANSLATION!!!
    let long_topic_name = topic_names[topic_index][1];
    document.getElementById('findings-consensus-sentiment-chart-title').innerHTML = long_topic_name;
    document.getElementById('findings-consensus-sentiment-chart-subtitle').innerHTML = topic_percent_string;

    function render_dots() {
      {# ctx.fillStyle = "#fff";
         ctx.fillRect(0, 0, canvas.width, canvas.height); 
       #}
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let nbr_applications = 6;
      for (let a = 0; a < nbr_applications; ++a) {
        apply_consensus_forces(ctx);
      }

      consensus_vars.user_dots.forEach(dot => {
        if (true) {
          dot.cx += (dot.tx - dot.cx) * 0.05;
          dot.cy += (dot.ty - dot.cy) * 0.1;
          dot.copacity += (dot.topacity - dot.copacity) * 0.1;

          let x = dot.cx;
          let y = dot.cy;
          let color = compute_color(dot.cx);

          // let er = consensus_vars.ellipse_radius * (1 + 1-dot.copacity); // grow as we fade out
          let er = consensus_vars.ellipse_radius;

          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x, y, er, er, 0, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.globalAlpha = dot.copacity;
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.restore();
        }

      });
      // ! clear the render handle if the amount of movement is neglible
    }

    console.log("beginning to render dots");
    render_dots();
    consensus_vars.render_handle = setInterval(render_dots, 40);
    draw_consensus_progress_bar(topic_index);

}

function setup_consensus_chart(itsVoteData) {
    setup_consensus_progress_bar();

    consensus_vars.voteData = itsVoteData;
    console.log("consensus_vars.voteData record 0", consensus_vars.voteData['user_recs'][0]);
    const canvas = document.getElementById('findings-consensus-sentiment-chart-dataviz-canvas');
    canvas.width = 1500;
    canvas.height = 400;

    consensus_vars.canvas = canvas;
    consensus_vars.ctx = canvas.getContext('2d');

    let userRecs = consensus_vars.voteData['user_recs'];

    consensus_vars.user_dots = [];

    const row_size = Math.round(Math.sqrt(topic_vars.voteData.nbr_users));
    const masonry_incx = 0.5 / row_size;

    for (let uid = 0; uid < consensus_vars.voteData.nbr_users; uid++) {
       let ryi = Math.floor(uid / row_size);
       let initRX = (uid % row_size) / row_size + ((ryi % 2) * masonry_incx);
       let initRY = (uid / row_size) / row_size;
       let initCY = consensus_vars.vert_margin + initRY * (canvas.height-consensus_vars.vert_margin*2);
        consensus_vars.user_dots.push({
            uid: uid,
            rx:  initRX,         // Math.random(),
            ry:  initRY,         // uid / topic_vars.voteData.nbr_users,
            cx: canvas.width/2,
            tx: 0,
            cy: initCY,
            ty: initCY,
            vx: 0,
            vy: 0,
            copacity: 0, // current opacity
            topacity: 0, // target opacity
        });
    }

    // Fill the canvas with white

    change_consensus_topic(canvas, 0);
    consensus_chart_phase(0);
}

function consensus_chart_phase(phase)
{
  const canvas = consensus_vars.canvas; //  document.getElementById('findings-consensus-sentiment-chart-dataviz-canvas');
  consensus_vars.phase = phase;
  console.log("consensus_chart_phase", phase);
  if (canvas == null) {
    return;
  }
  switch (phase) {
  case 1:
    if (consensus_vars.phase_handle) {
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = null;
    }
    break;
  case 3:
    if (consensus_vars.phase_handle) {
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = null;
    }
    break;
  case 2:
    console.log("Setting up phase 2 timers");
    setTimeout(() => {
      console.log("Setting up phase 2 timeout");
      change_consensus_topic(canvas, (consensus_vars.topic_number + 1 ) % consensus_vars.voteData.topics.length);
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = setInterval(() => {
          change_consensus_topic(canvas, (consensus_vars.topic_number + 1 ) % consensus_vars.voteData.topics.length);
      }, 5000);
    }, 1000);
    break;
  }


}


let cprogress_vars = {
  "ellipse_radius": 7.91,
  "step_number": 0,
  "nbr_topics": 19,
  "canvas": null,
  "ctx": null
};

function draw_consensus_progress_bar(step_index) {
  let ctx = cprogress_vars.ctx;
  if (ctx == null) {
    return;
  }
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  ctx.fillStyle = "#000";

  // Draw a series of ellipses across the bar, one per topic
  let n = cprogress_vars.nbr_topics;
  let w = ctx.canvas.width;
  let h = ctx.canvas.height;
  let r = cprogress_vars.ellipse_radius;
  let dot_grow = 24/16;
  let hmargin = r*dot_grow; // maximum dot radius
  let gap = (w - 2 * hmargin) / (n - 1);

  for (let i = 0; i < n; i++) {
    let x = hmargin + i * gap;
    let y = h / 2;
    let clr = compute_color(x);
    let fill_color = step_index == i? '#000' : clr;
    ctx.save();
    if (i < n-1) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + gap, y);
      ctx.lineWidth = 4;
      ctx.strokeStyle = clr;
      ctx.stroke();
    }
    ctx.beginPath();
    let radius = (step_index == i)? r*dot_grow : r;
    ctx.ellipse(x, y, radius, radius, 0, 0, 2 * Math.PI);
    ctx.fillStyle = fill_color;
    ctx.globalAlpha = 1;
    ctx.fill();
    ctx.restore();
  }
}

function setup_consensus_progress_bar()
{
    const canvas = document.getElementById('findings-consensus-progressbar-canvas');
    canvas.width = 1500;
    canvas.height = 24;

    cprogress_vars.canvas = canvas;
    cprogress_vars.ctx = canvas.getContext('2d');

    // Fill the canvas with white

    draw_consensus_progress_bar(0);
}

</script>