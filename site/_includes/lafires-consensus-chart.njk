<script>

let consensus_vars = {
  "user_dots": [],
  "bandWidth": 0,
  "adj_band": 0,
  "ellipse_radius": 10,
  "voteData": null,
  "render_handle": null,
  "phase_handle": null,
  "phase": -1,
  "topic_number": 0,
  "canvas": null,
  "ctx": null
};


// UTILS
function mapv(v, in_min, in_max, out_min, out_max) {
  return (v-in_min) * (out_max-out_min) / (in_max-in_min) + out_min;
}

function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}

function compute_color(cx) {
  let r = cx/1200;
  let hue,sat,val;
  if (r < 0.5) {
    sat = Math.round(clamp(mapv(r, 0, 0.5, 76, 0),0,76)*100)/100;
    val = Math.round(clamp(mapv(r, 0, 0.5, 61, 85),61,85)*100)/100;
  } else {
    sat = Math.round(clamp(mapv(r, 0.5, 1, 0, 32),0,32)*100)/100;
    val = Math.round(clamp(mapv(r, 0.5, 1, 85, 48),48,85)*100)/100;
  }
  hue = Math.round(clamp(mapv(r,0.45, 0.55, 27, 200), 27, 200)*100)/100;
  return "hsl(" + hue + ", " + sat + "%, " + val + "%)";
}

// color debugging
for (let i = 0; i < 7; ++i) {
  let cx = mapv(i,0,6,0,1200);
  let color = compute_color(cx);
  console.log("color",i+1, color);
}

function reset_user_dots(topic_index) {
    let userRecs = consensus_vars.voteData['user_recs'];
    let fUserRecords = userRecs.filter(rec => rec.tid == topic_index);

    let encountered_uids = {};

    fUserRecords.forEach(rec => {
      let uid = rec.uid;
      encountered_uids[uid] = true;
      let user_dot = consensus_vars.user_dots[uid];

      let likert = rec.v;
      // Clamp likert to [1,7]
      if (likert < 1) likert = 1;
      if (likert > 7) likert = 7;
      let x = consensus_vars.bandWidth * (likert - 0.5);
      x_offset = user_dot.rx * consensus_vars.adj_band - consensus_vars.adj_band / 2;
      x += x_offset;
      user_dot.tx = x;
      user_dot.topacity = 1;

      if (user_dot.copacity < 0.1) {
        user_dot.cx = user_dot.tx;
      }
    });

    // For each user that is not in the fUserRecords, set the opacity to 0
    for (let uid = 0; uid < consensus_vars.voteData.nbr_users; uid++) {
      if (!encountered_uids[uid]) {
        consensus_vars.user_dots[uid].topacity = 0;
        consensus_vars.user_dots[uid].tx = consensus_vars.user_dots[uid].cx;
      }
    }
}


function change_consensus_topic(canvas, topic_index) {
    // console.log("render_topic", topic_index);
    consensus_vars.topic_number = topic_index;
    let ctx = canvas.getContext('2d');
    consensus_vars.bandWidth = ctx.canvas.width / 7;
    consensus_vars.adj_band = consensus_vars.bandWidth - consensus_vars.ellipse_radius*2;

    if (consensus_vars.render_handle) {
      clearInterval(consensus_vars.render_handle);
    }


    reset_user_dots(topic_index);
    let topic_names = consensus_vars.voteData['topics'];
    let topic_number_template = '{{ modules.findings_consensus_watch_explore.topic_number_template | safe}}';
    let topic_number_string = topic_number_template.replace('<NUM>', topic_index + 1).replace('<TOTAL>', topic_names.length);
    document.getElementById('findings-consensus-sentiment-chart-topic-number').innerHTML = topic_number_string;
    // let topic_number_label = f'Topic {topic_index + 1} of {topic_names.length}'; // TRANSLATION!!!
    let long_topic_name = topic_names[topic_index][1];
    document.getElementById('findings-consensus-sentiment-chart-title').innerHTML = long_topic_name;

    function render_dots() {
      {# ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height); #}
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      consensus_vars.user_dots.forEach(dot => {
        if (true) {
          dot.cx += (dot.tx - dot.cx) * 0.05;
          dot.copacity += (dot.topacity - dot.copacity) * 0.1;

          let x = dot.cx;

          let y = consensus_vars.ellipse_radius + dot.ry * (ctx.canvas.height-consensus_vars.ellipse_radius*2);
          let color = compute_color(dot.cx);

          // let er = consensus_vars.ellipse_radius * (1 + 1-dot.copacity); // grow as we fade out
          let er = consensus_vars.ellipse_radius;

          ctx.save();
          ctx.beginPath();
          ctx.ellipse(x, y, er, er, 0, 0, 2 * Math.PI);
          ctx.fillStyle = color;
          ctx.globalAlpha = dot.copacity;
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.restore();
        }

      });
    }

    console.log("beginning to render dots");

    consensus_vars.render_handle = setInterval(render_dots, 40);
    draw_consensus_progress_bar(topic_index);

}

function setup_consensus_chart(itsVoteData) {
    setup_consensus_progress_bar();

    consensus_vars.voteData = itsVoteData;
    console.log("consensus_vars.voteData record 0", consensus_vars.voteData['user_recs'][0]);
    const canvas = document.getElementById('findings-consensus-sentiment-chart-dataviz-canvas');
    canvas.width = 1500;
    canvas.height = 310;

    consensus_vars.canvas = canvas;
    consensus_vars.ctx = canvas.getContext('2d');

    let userRecs = consensus_vars.voteData['user_recs'];

    consensus_vars.user_dots = [];

    for (let uid = 0; uid < consensus_vars.voteData.nbr_users; uid++) {
        consensus_vars.user_dots.push({
            uid: uid,
            rx: Math.random(),
            ry: uid / consensus_vars.voteData.nbr_users,
            cx: 600,
            tx: 0,
            copacity: 0, // current opacity
            topacity: 0, // target opacity
        });
    }

    // Fill the canvas with white

    change_consensus_topic(canvas, 0);
    consensus_chart_phase(0);
}

function consensus_chart_phase(phase)
{
  const canvas = consensus_vars.canvas; //  document.getElementById('findings-consensus-sentiment-chart-dataviz-canvas');
  consensus_vars.phase = phase;
  console.log("consensus_chart_phase", phase);
  if (canvas == null) {
    return;
  }
  switch (phase) {
  case 1:
    if (consensus_vars.phase_handle) {
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = null;
    }
    break;
  case 3:
    if (consensus_vars.phase_handle) {
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = null;
    }
    break;
  case 2:
    console.log("Setting up phase 2 timers");
    setTimeout(() => {
      console.log("Setting up phase 2 timeout");
      change_consensus_topic(canvas, (consensus_vars.topic_number + 1 ) % consensus_vars.voteData.topics.length);
      clearInterval(consensus_vars.phase_handle);
      consensus_vars.phase_handle = setInterval(() => {
          change_consensus_topic(canvas, (consensus_vars.topic_number + 1 ) % consensus_vars.voteData.topics.length);
      }, 5000);
    }, 1000);
    break;
  }


}


let cprogress_vars = {
  "ellipse_radius": 7.91,
  "step_number": 0,
  "nbr_topics": 19,
  "canvas": null,
  "ctx": null
};

function draw_consensus_progress_bar(step_index) {
  let ctx = cprogress_vars.ctx;
  if (ctx == null) {
    return;
  }
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  ctx.fillStyle = "#000";

  // Draw a series of ellipses across the bar, one per topic
  let n = cprogress_vars.nbr_topics;
  let w = ctx.canvas.width;
  let h = ctx.canvas.height;
  let r = cprogress_vars.ellipse_radius;
  let gap = (w - 2 * r) / (n - 1);

  for (let i = 0; i < n; i++) {
    let x = r + i * gap;
    let y = h / 2;
    let clr = compute_color(x);
    let fill_color = step_index == i? '#000' : clr;
    ctx.save();
    if (i < n-1) {
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + gap, y);
      ctx.lineWidth = 4;
      ctx.strokeStyle = clr;
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.ellipse(x, y, r, r, 0, 0, 2 * Math.PI);
    ctx.fillStyle = fill_color;
    ctx.globalAlpha = 1;
    ctx.fill();
    ctx.restore();
  }
}

function setup_consensus_progress_bar()
{
    const canvas = document.getElementById('findings-consensus-progressbar-canvas');
    canvas.width = 1500;
    canvas.height = 16;

    cprogress_vars.canvas = canvas;
    cprogress_vars.ctx = canvas.getContext('2d');

    // Fill the canvas with white

    draw_consensus_progress_bar(0);
}

</script>